
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Mynote</title>
        <meta name="author" content="参商">
        <meta name="description" content="个人笔记">
        <meta name="keywords" content="love&peace">
        <link rel="icon" href="https://img.gejiba.com/images/39def1210a35239bb3777e2c504985f1.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">mynote</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;mynote</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(https://img.gejiba.com/images/fb4fd20b295fa6af03f3d21094d319cb.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>mynote</h1>
                <h3></h3>
                <h5>个人笔记</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class=>
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/11/07/echarts的入门整理/">
        <h2>
            Echarts的入门整理
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/11/7
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1.安装方式"></a>1.安装方式</h2><pre><code>npm install echarts --save
</code></pre>
<h2 id="2-引入-ECharts"><a href="#2-引入-ECharts" class="headerlink" title="2.引入 ECharts"></a>2.引入 ECharts</h2><pre><code>import * as echarts from &#39;echarts&#39;;
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById(&#39;main&#39;));
// 绘制图表
myChart.setOption(&#123;
  title: &#123;
    text: &#39;ECharts 入门示例&#39;
  &#125;,
  tooltip: &#123;&#125;,
  xAxis: &#123;
    data: [&#39;衬衫&#39;, &#39;羊毛衫&#39;, &#39;雪纺衫&#39;, &#39;裤子&#39;, &#39;高跟鞋&#39;, &#39;袜子&#39;]
  &#125;,
  yAxis: &#123;&#125;,
  series: [
    &#123;
      name: &#39;销量&#39;,
      type: &#39;bar&#39;,
      data: [5, 20, 36, 10, 10, 20]
    &#125;
  ]
&#125;);
</code></pre>
<h2 id="3-图表容器及大小"><a href="#3-图表容器及大小" class="headerlink" title="3.图表容器及大小"></a>3.图表容器及大小</h2><h5 id="1-在-HTML-中定义有宽度和高度的父容器（推荐）"><a href="#1-在-HTML-中定义有宽度和高度的父容器（推荐）" class="headerlink" title="1.在 HTML 中定义有宽度和高度的父容器（推荐）"></a>1.在 HTML 中定义有宽度和高度的父容器（推荐）</h5><p>通常来说，需要在 HTML 中先定义一个 <code>&lt;div&gt;</code> 节点，并且通过 CSS 使得该节点具有宽度和高度。初始化的时候，传入该节点，图表的大小默认即为该节点的大小，除非声明了 <code>opts.width</code> 或 <code>opts.height</code> 将其覆盖。需要注意的是，使用这种方法在调用 <code>echarts.init</code> 时需保证容器已经有宽度和高度了。</p>
<pre><code>&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;));
&lt;/script&gt;
</code></pre>
<h5 id="2-指定图表的大小"><a href="#2-指定图表的大小" class="headerlink" title="2.指定图表的大小"></a>2.指定图表的大小</h5><p>如果图表容器不存在宽度和高度，或者，你希望图表宽度和高度不等于容器大小，也可以在初始化的时候指定大小。</p>
<pre><code>&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;), null, &#123;
    width: 600,
    height: 400
  &#125;);
&lt;/script&gt;
</code></pre>
<h5 id="3-响应容器大小的变化"><a href="#3-响应容器大小的变化" class="headerlink" title="3.响应容器大小的变化"></a>3.响应容器大小的变化</h5><p>监听图标容器的大小并改变图表大小</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;));
  window.onresize = function() &#123;
    myChart.resize();
  &#125;;
&lt;/script&gt;
</code></pre>
<h5 id="4-为图表设置特定的大小"><a href="#4-为图表设置特定的大小" class="headerlink" title="4.为图表设置特定的大小"></a>4.为图表设置特定的大小</h5><p>除了直接调用 <code>resize()</code> 不含参数的形式之外，还可以指定宽度和高度，实现图表大小不等于容器大小的效果。</p>
<pre><code>myChart.resize(&#123;
  width: 800,
  height: 400
&#125;);
</code></pre>
<h3 id="4-容器节点被销毁以及被重建时"><a href="#4-容器节点被销毁以及被重建时" class="headerlink" title="4.容器节点被销毁以及被重建时"></a>4.容器节点被销毁以及被重建时</h3><p>假设页面中存在多个标签页，每个标签页都包含一些图表。当选中一个标签页的时候，其他标签页的内容在 DOM 中被移除了。这样，当用户再选中这些标签页的时候，就会发现图表“不见”了。</p>
<p>本质上，这是由于图表的容器节点被移除导致的。即使之后该节点被重新添加，图表所在的节点也已经不存在了。</p>
<p>正确的做法是，在图表容器被销毁之后，调用 <a target="_blank" rel="noopener" href="https://echarts.apache.org/api.html#echartsInstance.dispose"><code>echartsInstance.dispose</code></a> 销毁实例，在图表容器重新被添加后再次调用 <a target="_blank" rel="noopener" href="https://echarts.apache.org//api.html#echarts.init">echarts.init</a> 初始化。</p>
<p>完整基础用法：</p>
<pre><code>    async mounted() &#123;
      window.addEventListener(&#39;resize&#39;, () =&gt; &#123;
        this.myChart.resize()
      &#125;)
    &#125;,
     //收支情况柱状图
      drawTotalChart() &#123;
        if (
          this.myChart != null &amp;&amp;
          this.myChart != &#39;&#39; &amp;&amp;
          this.myChart != undefined
        ) &#123;
          this.myChart.dispose()
        &#125;
        let chartDom = document.getElementById(&#39;totalmain&#39;)
        this.myChart = echarts.init(chartDom)

        let option = &#123;
          color: [&#39;rgba(96, 154, 240, 1)&#39;, &#39;rgba(107, 204, 212, 1)&#39;],
          tooltip: &#123;
            trigger: &#39;axis&#39;,
            axisPointer: &#123;
              type: &#39;shadow&#39;,
            &#125;,
          &#125;,
          grid: &#123;
            top: 50,
            left: 0,
            right: 0,
            bottom: 20,
            containLabel: true,
          &#125;,
          legend: &#123;
            data: [&#39;收入&#39;, &#39;支出&#39;],
            x: &#39;left&#39;,
            padding: [0, 0, 0, 0],
            itemStyle: &#123;&#125;,
          &#125;,
          xAxis: &#123;
            type: &#39;category&#39;,
            data: this.monthList,
          &#125;,
          yAxis: &#123;&#125;,
          series: [
            &#123; data: this.totalincome, type: &#39;bar&#39;, name: &#39;收入&#39; &#125;,
            &#123; data: this.totalspend, type: &#39;bar&#39;, name: &#39;支出&#39; &#125;,
          ],
        &#125;
        option &amp;&amp; this.myChart.setOption(option)
      &#125;,
    
</code></pre>
<h2 id="5-ECharts-中的样式"><a href="#5-ECharts-中的样式" class="headerlink" title="5.ECharts 中的样式"></a>5.ECharts 中的样式</h2><h5 id="1-颜色主题"><a href="#1-颜色主题" class="headerlink" title="1.颜色主题"></a>1.颜色主题</h5><ul>
<li>ECharts 中默认内置了两套主题: light dark。可以像这样切换成深色模式：</li>
</ul>
<pre><code>var chart = echarts.init(dom, &#39;dark&#39;);
</code></pre>
<ul>
<li><p>其他的主题，没有内置在 ECharts 中，需要自己加载</p>
</li>
<li><p>在echarts资源&#x2F;主题构建工具中下载需要的主题并引入,在echarts初始化时，使用主题。可以使用多个不同的主题。例如：</p>
</li>
</ul>
<p><code>let myChart = echarts.init(document.getElementById(&quot;School&quot;),&#39;macarons&#39;);</code></p>
<ul>
<li>注意：使用时不能自己指定color，否则主题的颜色将失效，变为指定的颜色</li>
</ul>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/1.jpg"></p>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/2.jpg"></p>
<pre><code>  import &#39;@/utils/purple-passion&#39;
  import &#39;@/utils/infographic&#39;
  
  let chartDom = document.getElementById(&#39;paymentMain&#39;)
  this.paymentMyChart = echarts.init(chartDom, &#39;infographic&#39;)
   
  let chartDom = document.getElementById(&#39;totalmain&#39;)
  this.myChart = echarts.init(chartDom, &#39;purple-passion&#39;)
</code></pre>
<h5 id="2-调色盘"><a href="#2-调色盘" class="headerlink" title="2.调色盘"></a>2.调色盘</h5><p>调色盘，可以在 option 中设置。它给定了一组颜色，图形、系列会自动从其中选择颜色。 可以设置全局的调色盘，也可以设置系列自己专属的调色盘。</p>
<pre><code>option = &#123;
  // 全局调色盘。
  color: [
    &#39;#c23531&#39;,
    &#39;#2f4554&#39;,
    &#39;#61a0a8&#39;,
    &#39;#d48265&#39;,
    &#39;#91c7ae&#39;,
    &#39;#749f83&#39;,
    &#39;#ca8622&#39;,
    &#39;#bda29a&#39;,
    &#39;#6e7074&#39;,
    &#39;#546570&#39;,
    &#39;#c4ccd3&#39;
  ],

  series: [
    &#123;
      type: &#39;bar&#39;,
      // 此系列自己的调色盘。
      color: [
        &#39;#dd6b66&#39;,
        &#39;#759aa0&#39;,
        &#39;#e69d87&#39;,
        &#39;#8dc1a9&#39;,
        &#39;#ea7e53&#39;,
        &#39;#eedd78&#39;,
        &#39;#73a373&#39;,
        &#39;#73b9bc&#39;,
        &#39;#7289ab&#39;,
        &#39;#91ca8c&#39;,
        &#39;#f49f42&#39;
      ]
      // ...
    &#125;,
    &#123;
      type: &#39;pie&#39;,
      // 此系列自己的调色盘。
      color: [
        &#39;#37A2DA&#39;,
        &#39;#32C5E9&#39;,
        &#39;#67E0E3&#39;,
        &#39;#9FE6B8&#39;,
        &#39;#FFDB5C&#39;,
        &#39;#ff9f7f&#39;,
        &#39;#fb7293&#39;,
        &#39;#E062AE&#39;,
        &#39;#E690D1&#39;,
        &#39;#e7bcf3&#39;,
        &#39;#9d96f5&#39;,
        &#39;#8378EA&#39;,
        &#39;#96BFFF&#39;
      ]
      // ...
    &#125;
  ]
&#125;;
</code></pre>
<h5 id="3-高亮的样式：emphasis"><a href="#3-高亮的样式：emphasis" class="headerlink" title="3.高亮的样式：emphasis"></a>3.高亮的样式：emphasis</h5><p>在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。但是高亮的样式也可以自己定义，主要是通过 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.emphasis">emphasis</a> 属性来定制。<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.emphasis">emphsis</a> 中的结构，和普通样式的结构相同，例如：</p>
<pre><code>         series: [
            &#123;
              name: &#39;报销&#39;,
              type: &#39;pie&#39;,
              radius: &#39;90%&#39;,
              hoverAnimation: false,
              emphasis: &#123;
                itemStyle: &#123;
                  // 高亮时点的颜色。
                  color: &#39;skyblue&#39;,
                &#125;,
                label: &#123;
                  show: true,
                  // 高亮时标签的文字。
                  formatter: &#39;This is a emphasis label.&#39;,
                &#125;,
              &#125;,
              label: &#123;
                normal: &#123;
                  show: true,
                  formatter: &#39;&#123;d&#125;%&#39;,
                  position: &#39;inner&#39;,
                  textStyle: &#123;
                    align: &#39;center&#39;,
                    baseline: &#39;middle&#39;,
                    fontFamily: &#39;微软雅黑&#39;,
                    fontSize: 14,
                    color: &#39;white&#39;,
                  &#125;,
                &#125;,
                labelLine: &#123;
                  show: false,
                &#125;,
              &#125;,
              data: this.data.reservationReimburseItemList,
            &#125;,
          ],
</code></pre>
<h5 id="4-直接的样式设置"><a href="#4-直接的样式设置" class="headerlink" title="4.直接的样式设置"></a>4.直接的样式设置</h5><p>直接的样式设置是比较常用设置方式。纵观 ECharts 的 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#">option</a> 中，很多地方可以设置 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.itemStyle">itemStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-line.lineStyle">lineStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-line.areaStyle">areaStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.label">label</a> 等等。这些的地方可以直接设置图形元素的颜色、线宽、点的大小、标签的文字、标签的样式等等。上面的示例中已举例</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/echarts" style="color: #ff7d73">
                echarts
            </a>
        </span>
        
    </div>
    <a href="/2022/11/07/echarts的入门整理/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/10/24/vue3中的watch和computed/">
        <h2>
            Vue3中的watch和computed
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/24
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="a-computed"><a href="#a-computed" class="headerlink" title="a) computed"></a>a) computed</h2><p>computed函数用来创造计算属性，和过去一样，它返回的值是一个ref对象。里面可以传方法，或者一个对象，对象中包含set()、get()方法</p>
<p><strong>只读的计算属性：</strong></p>
<pre><code class="javascript">  姓: &lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot; /&gt; &lt;br /&gt;
  名: &lt;input type=&quot;text&quot; v-model=&quot;person.lastName&quot; /&gt; &lt;br /&gt;
  &lt;span&gt;全名:&#123;&#123; person.fullName &#125;&#125;&lt;/span&gt;

import &#123; reactive, computed &#125; from &quot;vue&quot;;
setup() &#123;
    const person = reactive(&#123;
      firstName: &quot;张&quot;,
      lastName: &quot;三&quot;,
    &#125;);

    person.fullName = computed(() =&gt; &#123;
      return person.firstName + &quot;-&quot; + person.lastName;
    &#125;);

    return &#123; person &#125;;
  &#125;,
</code></pre>
<p><strong>可读可改的计算属性：</strong></p>
<pre><code class="javascript">   姓: &lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot; /&gt; &lt;br /&gt;
   名: &lt;input type=&quot;text&quot; v-model=&quot;person.lastName&quot; /&gt; &lt;br /&gt;
   全名：&lt;input type=&quot;text&quot; v-model=&quot;person.fullName&quot; /&gt; &lt;br /&gt;
   import &#123; reactive, computed &#125; from &quot;vue&quot;;
     setup() &#123;
    const person = reactive(&#123;
      firstName: &quot;张&quot;,
      lastName: &quot;三&quot;,
    &#125;);
    //完整形式
    person.fullName = computed(&#123;
      get() &#123;
        return person.firstName + &quot;-&quot; + person.lastName;
      &#125;,
      set(value) &#123;
        const nameArr = value.split(&quot;-&quot;);
        person.firstName = nameArr[0];
        person.lastName = nameArr[1];
      &#125;,
    &#125;);

    return &#123; person &#125;;
  &#125;,    
   
</code></pre>
<h2 id="b-watch"><a href="#b-watch" class="headerlink" title="b) watch"></a>b) watch</h2><p>与vue2中watch配置功能一致</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取，强制开启了深度监视（deep配置失效）</li>
<li>监视reactive定义的响应式数据中某个属性(对象)时，deep配置有效</li>
</ul>
<p> <strong>1.监视ref定义的一个响应式对象</strong></p>
<pre><code class="javascript"> let count = ref(0);
    let msg = ref(&quot;你好啊&quot;);

    const person = reactive(&#123;
      name: &quot;张三&quot;,
      age: 18,
      jobs: &#123;
        job1: &#123;
          salary: 20,
        &#125;,
      &#125;,
    &#125;);


    watch(count, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;count的值改变了&quot;, newVal, oldVal);
    &#125;);
</code></pre>
<p> <strong>2.监视ref定义的多个响应式对象</strong></p>
<pre><code>   watch(
      [count, msg],
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;count或者msg的数据改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; immediate: true, deep: true &#125;
    );
    
    
</code></pre>
<p><strong>3.监视reactive定义的响应式对象的全部属性,但是这里无法正确的获取oldVal,强制开启了深度监视(deep配置无效)</strong></p>
<pre><code>  watch(person, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person改变了&quot;, newVal, oldVal);
    &#125;,&#123;deep:false&#125;);//deep配置无效
</code></pre>
<p><strong>4.监视reactive定义的响应式数据的一个属性，这种方式可获取oldVal</strong></p>
<pre><code> watch(
      () =&gt; person.age,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的age改变了&quot;, newVal, oldVal);
      &#125;
    );
</code></pre>
<p><strong>5.监视reactive定义的响应式数据的某些属性,这种方式可获取oldVal</strong></p>
<pre><code>    watch([() =&gt; person.age, () =&gt; person.name], (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person的age或name改变了&quot;, newVal, oldVal);
    &#125;);
</code></pre>
<p><strong>6.特殊情况，监视reactive定义的响应式对象中的某个对象,这里deep配置有效，获取不到oldVal</strong></p>
<pre><code>    watch(
      () =&gt; person.jobs,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的job改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; deep: true &#125;
    );
</code></pre>
<p><strong>7.ref定义的响应式对象</strong></p>
<p>如果定义的对象是基本数据，则不用加<code>.value</code>,例如<code> let count=ref(0)</code>,如果在监视时加了<code>.value</code>，则监视的则是0这个数字，不是我们想要的refImpl数据对象，如果定义的对象是一个对象，则需要加<code>.value</code>，否则监听时虽然对象内的数据改变，但整个对象没有改变（其内存地址没有发生变化），会认为没有发生变化，也就监听不到对象内数据的变化</p>
<pre><code>    const person = ref(&#123;
      name: &quot;张三&quot;,
      age: 18,
      jobs: &#123;
        job1: &#123;
          salary: 20,
        &#125;,
      &#125;,
    &#125;);



1.数据为对象时，需要加.value
 watch(person.value, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person的值改变了&quot;, newVal, oldVal);
    &#125;);
2.若不加.value，则需要深度监听(deep:true)，才能监听到对象的改变
    watch(
      person,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的值改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; deep: true &#125;
    );
</code></pre>
<h1 id="watch和watchEffect"><a href="#watch和watchEffect" class="headerlink" title="watch和watchEffect"></a>watch和watchEffect</h1><h4 id="a-纯函数与副作用"><a href="#a-纯函数与副作用" class="headerlink" title="a) 纯函数与副作用"></a>a) 纯函数与副作用</h4><p>effect全称叫side effect，副作用。</p>
<p>什么是副作用呢，一个函数运行后产生了可以影响其外部或可以看到的效果，就叫副作用，比如document. Body. Append，alert再或者是showModel（在页面中展示一个弹层），或者window.open打开一个新窗口。<br><img src="/2022/10/24/vue3%E4%B8%AD%E7%9A%84watch%E5%92%8Ccomputed/%E8%AF%BE%E4%BB%B6/19.Vue3%E8%BF%9B%E9%98%B6&vite/19.Vue3%E8%BF%9B%E9%98%B6&vite/readme/assets/Snipaste_2021-11-23_10-58-18.jpg" alt="Snipaste_2021-11-23_10-58-18"></p>
<pre><code class="javascript">// 纯函数：如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。它不应修改程序的状态或引起副作用。
function priceAfterTax(productPrice) &#123; 
    return (productPrice * 0.20) + productPrice;
&#125;

// 副作用：一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。
var tax = 20;
function calculateTax(productPrice) &#123;
    tax = tax/100
    return (productPrice * tax) + productPrice;
&#125;
</code></pre>
<ul>
<li><p>react中副作用可以这样理解：组件初始化的时候，组件根据开发者的设定，由自身驱动的第一次DOM修改，就是主作用。主作用之后，组件开始执行用户逻辑，这时你眼里的业务逻辑代码，在React眼里都是副作用。</p>
</li>
<li><p>vue3中的副作用与react中副作用的定义类似，响应式数据的变更造成的其他连锁反应，以及后续逻辑，这些连锁反应都叫副作用。</p>
</li>
</ul>
<p>哪些函数没有副作用呢，只用来计算结果的函数，比如Math.max，JSON.parse，它们的运行除了返回结果外不会有其它效果，这就叫不产生副作用。</p>
<p>基本上可以简化的理解为副作用就是执行某种操作(副作用函数)，无副作用就是执行某种计算(纯函数)。</p>
<p>这里watchEffect的意思就是在观察（watch）到变化后执行一些操作（effect）。</p>
<h4 id="b-watchEffect的基本使用"><a href="#b-watchEffect的基本使用" class="headerlink" title="b) watchEffect的基本使用"></a>b) watchEffect的基本使用</h4><pre><code class="javascript">import &#123; watchEffect, ref &#125; from &#39;vue&#39;
setup () &#123;
    const userID = ref(0)
    
    watchEffect(() =&gt; console.log(userID))
    
    setTimeout(() =&gt; &#123;
      userID.value = 1
    &#125;, 1000)

    return &#123;
      userID
    &#125;
 &#125;
</code></pre>
<h4 id="c-watch和watchEffect的异同"><a href="#c-watch和watchEffect的异同" class="headerlink" title="c) watch和watchEffect的异同"></a>c) watch和watchEffect的异同</h4><p>watch和watchEffect都可以侦听副作用，区别在于：</p>
<ul>
<li>第一点我们可以从示例代码中看到 <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行；而 <code>watch</code> 只能监听指定的属性而做出变更。</li>
<li>第二点就是 watch 可以获取到新值与旧值（更新前的值），而 <code>watchEffect</code> 是拿不到的。</li>
<li>第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行；而 watch 不需要，因为他一开始就指定了依赖。</li>
</ul>
<h4 id="d-watchEffect的刷新时机"><a href="#d-watchEffect的刷新时机" class="headerlink" title="d) watchEffect的刷新时机"></a>d) watchEffect的刷新时机</h4><p>watchEffect会在所有的组件 <code>update</code> <strong>前</strong>执行。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  setup() &#123;
    const count = ref(0)

    watchEffect(() =&gt; &#123;
      console.log(count.value)
    &#125;)

    return &#123;
      count
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>在这个例子中：</p>
<ul>
<li><code>count</code> 会在初始运行时同步打印出来，因为watchEffect会在组件初始化的时候默认收集一次依赖</li>
<li>更改 <code>count</code> 时，将在组件<strong>更新前</strong>执行副作用。</li>
</ul>
<p>如果需要在组件更新(例如：当与<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-template-refs.html#%E4%BE%A6%E5%90%AC%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8">模板引用</a>一起)<strong>后</strong>重新运行侦听器副作用，我们可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p>
<pre><code class="javascript">watchEffect(
  () =&gt; &#123;
    /* ... */
  &#125;,
  &#123;
    flush: &#39;post&#39;
  &#125;
)
</code></pre>
<h4 id="e-停止侦听"><a href="#e-停止侦听" class="headerlink" title="e) 停止侦听"></a>e) 停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>
<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>
<pre><code class="javascript">const stop = watchEffect(() =&gt; &#123;
  /* ... */
&#125;)

stop()
</code></pre>
<h4 id="f-清除副作用的函数"><a href="#f-清除副作用的函数" class="headerlink" title="f) 清除副作用的函数"></a>f) 清除副作用的函数</h4><p>watchEffect函数的onInvalidate方法就是用来清除副作用的，但副作用不一定是不被需要的。它可以是获取数据、事件监听或订阅、改变应用状态、修改 DOM、输出日志等等。清除副作用实际上是Vue3提供给用户的一种取消异步副作用的实现方法。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;
    &lt;button @click=&quot;doAdd&quot;&gt;点我+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, watchEffect, watch &#125; from &quot;vue&quot;;

export default &#123;
  setup() &#123;
    const count = ref(1);

    const doAdd = ()=&gt;&#123;
      count.value++
    &#125;

    watchEffect(onInvalidate =&gt; &#123;
      console.log(count.value)
      // 异步api调用，返回一个操作对象
      const timer = setInterval(() =&gt; &#123;
        console.log(&quot;timer执行了&quot;)
      &#125;, 1000);

      //onInvalidate(fn)传入的回调会在watchEffect重新运行或者watchEffect停止的时候执行。
      onInvalidate(()=&gt;&#123;
        clearInterval(timer)
      &#125;)
    &#125;);

    return &#123;
      count,
      doAdd
    &#125;;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<h3 id><a href="#" class="headerlink" title></a></h3>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ff7d73">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/10/24/vue3中的watch和computed/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/10/18/vue3中的响应式原理/">
        <h2>
            Vue3中的响应式原理
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>vue2.x的响应式：</p>
<p>实现原理：</p>
<p>对象类型：通过<code>Object.definProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹）</p>
<pre><code>Objet.defineProperty(data,&#39;count&#39;,&#123;
    get()&#123;&#125;,
    set()&#123;&#125;
&#125;)
</code></pre>
<p>存在问题：</p>
<p>新增属性、删除属性，界面不会更新</p>
<p>直接通过下标修改数组，界面不会自动更新</p>
<p>vue3.x的响应式</p>
<p>实现原理：</p>
<p>通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的增加、属性的删除等</p>
<p>通过Reflect  (反射)  ：对源对象的属性进行操作</p>
<p>模拟vue3中实现响应式</p>
<pre><code>//源数据
let person=&#123;
    name:&#39;张三&#39;,
    age:18
&#125;
const p=new Proxy(person,&#123;
    //有人读取p的某个属性时调用
    get(target,propName)&#123;
    console.log(`有人读取了p身上的$&#123;propName&#125;属性`)
    return Reflect.get(target,propName)
    &#125;，
    //有人修改p的某个属性、或给p追加某个属性时调用
    set(target,propName,value)&#123;
    console.log(`有人修改了了p身上的$&#123;propName&#125;属性`)
    Reflect.set(target,propName,value)
    &#125;,
    //有人删除p的某个属性时调用
    deleteProperty(target,propName)&#123;
    console.log(`有人删除了p身上的$&#123;propName&#125;属性`)
    return Reflect.deleteProperty(target,peopName)
    &#125;，
&#125;)
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ff7d73">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/10/18/vue3中的响应式原理/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/09/26/ref与reactive/">
        <h2>
            Ref与reactive
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h3 id="1-ref"><a href="#1-ref" class="headerlink" title="1. ref"></a>1. ref</h3><p>ref 用于为数据添加响应式状态，可以让某一个变量具备响应式的能力。由于reactive只能传入对象类型的参数，<strong>而对于基本数据类型要添加响应式状态就只能用ref了，同样返回一个具有响应式状态的副本。</strong></p>
<ul>
<li>在 js 中使用 ref 的值必须使用 .value 获取，在 Vue 的模板中使用 ref 的值不需要通过 value 获取</li>
<li>语法：const xxx&#x3D;ref(initValue),创建了一个包含响应式数据的引用对象</li>
<li>接收的数据可以是：基本类型、对象类型，对于基本数据类型，ref是自己的实现方式且性能优于reactive；而对于对象类型，ref仍然是通过reactive包装实现的</li>
<li>参数可以传递任意数据类型，传递对象类型时也能保持深度响应式，所以适用性更广。</li>
<li>vue 3.0 setup里定义数据时推荐优先使用ref，方便逻辑拆分和业务解耦。</li>
</ul>
<pre><code class="javascript">import &#123; ref &#125; from &quot;vue&quot;;

setup() &#123;
    const msg = &quot;张晓明&quot;;
    let age = ref(18);
    function add() &#123;
      age.value += 1;
    &#125;
    return &#123; msg, age, add &#125;;
&#125;
</code></pre>
<h3 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2. reactive"></a>2. reactive</h3><p>经过reactive函数处理后的对象能变成响应式的对象，类似于option api里面的data属性的值，<strong>它主要是处理你的对象让它经过 <code>Proxy</code> 的加工变为一个响应式的对象。</strong></p>
<p><strong>注意点：</strong></p>
<ul>
<li><p>语法：<code>const 代理对象=reactive(源对象)</code>,接收一个对象(或数组),返回一个代理对象(proxy对象)</p>
</li>
<li><p>如果想要保持对象内容的响应式能力，在 return 的时候必须把整个 <code>reactive()</code> 对象返回出去</p>
</li>
<li><p>在引用的时候也必须对整个对象进行引用而无法解构，否则这个对象内容的响应式能力将会丢失。</p>
</li>
<li><p><code>reactive()</code>只能包装对象,基本类型不要用它，要用ref函数</p>
</li>
<li><p>reactive定义的响应式数据是深层次的，内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</p>
</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; state.name &#125;&#125; 价格:&#123;&#123; state.price &#125;&#125;
    购买数量:&#123;&#123;state.count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      state.count += 1;
    &#125;
    return &#123; state, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="3-isRef-amp-toRefs-amp-toRef"><a href="#3-isRef-amp-toRefs-amp-toRef" class="headerlink" title="3. isRef &amp; toRefs &amp; toRef"></a>3. isRef &amp; toRefs &amp; toRef</h3><h4 id="a-isRef"><a href="#a-isRef" class="headerlink" title="a) isRef"></a>a) isRef</h4><p>用来判断某个值是否为ref创建出来的对象。</p>
<pre><code class="javascript">import &#123; ref, isRef &#125; from &#39;vue&#39;;
export default &#123;
    setup () &#123;
        const count = ref(1);
        const unwrappend = isRef(count) ? count.value : count;
 
        return &#123;
           count,
           unwrappend
        &#125;;
    &#125;
&#125;
</code></pre>
<h4 id="b-toRefs"><a href="#b-toRefs" class="headerlink" title="b) toRefs"></a>b) toRefs</h4><p>但是在具体的业务中，如果无法使用解构取出 <code>reactive()</code> 对象的值，每次都需要通过 <code>state.</code> 操作符访问它里面的属性会是非常麻烦的，所以官方提供了 <code>toRefs()</code> 函数来为我们填好这个坑。只要使用 <code>toRefs()</code> 把 <code>reactive()</code> 对象包装一下，就能够通过解构单独使用它里面的内容了。</p>
<p>toRefs 用于将响应式对象转换为结果对象，其中结果对象的每个属性都是指向原始对象相应属性的ref。</p>
<ul>
<li>toRefs之后得到的ref引用在获取数据值的时候需要加.value</li>
<li>toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据</li>
<li>作用其实和 toRef 类似，只不过 toRef 是一个个手动赋值，而 toRefs 是自动赋值。</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; name &#125;&#125; 价格:&#123;&#123; price &#125;&#125;
    购买数量:&#123;&#123;count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive,toRefs &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      //下面两种写法等效
      state.count += 1;
      // stateRefs.count.value+=1;
    &#125;

    const stateRefs = toRefs(state)

    return &#123; ...stateRefs, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="c-toRef"><a href="#c-toRef" class="headerlink" title="c) toRef"></a>c) toRef</h4><p>概念：为源响应式对象上的某个属性创建一个ref对象，二者内部操作的是同一个数据值，更新时二者是同步的。相当于浅拷贝一个属性。</p>
<ul>
<li>toRef之后得到的ref属性在获取数据值的时候需要加.value</li>
<li>toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; name &#125;&#125; 价格:&#123;&#123; price &#125;&#125;
    购买数量:&#123;&#123;count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive,toRef &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      //下面两种写法等效
      //state.count += 1;
      count.value += 1;
    &#125;

    const count = toRef(state, &quot;count&quot;);

    return &#123; count, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="d-ref-reactive-toRefs-和-toRef的比较"><a href="#d-ref-reactive-toRefs-和-toRef的比较" class="headerlink" title="d) ref reactive toRefs 和 toRef的比较"></a>d) ref reactive toRefs 和 toRef的比较</h4><p>**ref : **原始数据没有变化，而ref“包裹的数据”变成了一个新的对象，而且模板有变化（相当于深拷贝）</p>
<p>**reactive : **reactive处理的数据无论是原始数据，“包裹后的数据”，还是模板，都有变化（代理模式）</p>
<p><strong>toRef</strong> : toRef处理的数据会有变化，而原始数据也有变化，如果toRef处理是非响应式数据，此时模板没有变化 （相当于浅拷贝，引用关系）</p>
<p><strong>toRefs</strong> : toRefs处理的数据响应变化，原始数据也响应变化，如果toRefs处理是非响应式数据，此时模板并没有变化（相当于浅拷贝，引用关系）</p>
<p><img src="/2022/09/26/ref%E4%B8%8Ereactive/ref%E6%AF%94%E8%BE%83.jpg" alt="ref比较"></p>
<p>备注：ref也可以用来定义对象或数组，但内部会自动通过reactive转为代理对象</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ff7d73">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/ref与reactive/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/09/26/setup/">
        <h2>
            Setup
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>1.理解：vue3.0中一个新的配置项，值为一个函数</p>
<p>2.setup是所有Composition API(组合API)表演的舞台</p>
<p>3.组件中所用到的：数据、方法等等，均要配置在setup中</p>
<p>4.setup函数的两种返回值</p>
<p>​    1.若要返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。</p>
<p>​    2.若返回一个渲染函数，则可以自定义渲染内容</p>
<p>5.注意点：</p>
<p>1.尽量不要与vue2.x配置混用</p>
<ul>
<li>vue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法。</li>
<li>但在setup中不能访问到vue2.x配置（data、methods、computed…）</li>
<li>如果有重名，setup优先</li>
</ul>
<p>2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性。</p>
<h3 id="1-setup"><a href="#1-setup" class="headerlink" title="1 setup"></a>1 setup</h3><p>vue3.0将组件的逻辑都写在了函数内部，<code>setup()</code>会取代options API的<code>data()</code>函数，返回一个对象暴露给模板。</p>
<p> <code>setup</code> 选项在组件创建<strong>之前</strong>执行(所以在setup内部无法通过this来访问组件对象)，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>
<p><code>setup</code> 函数是个新的入口函数，相当于 vue2.x 中 <code>beforeCreate </code>和 <code>created</code>，在 <code>beforeCreate</code> 之后 <code>created </code>之前执行。</p>
<p><strong>setup函数的特性：</strong></p>
<ul>
<li><p>使用Composition API 的入口</p>
</li>
<li><p>在beforeCreate之后在created之前执行</p>
</li>
<li><p>在setup中没有this,或者说this是undefined</p>
</li>
<li><p>可以返回一个对象，这个对象的属性被合并到渲染上下文，并可以在模板中直接使用；</p>
</li>
<li><p>接收props对象作为第一个参数，接收来的props对象，包含组件外部传递过来，且组件内部声明接收了的属性，可以通过watch监视其变化。</p>
</li>
<li><p>接受context对象作为第二个参数，这个对象包含attrs，slots，emit三个属性。</p>
<p>​       attrs:值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于<code>this.$attrs</code></p>
<p>​       slots:收到的插槽内容，相当于<code>this.$slots</code></p>
<p>​       emit:分发的自定义事件函数，相当于<code>this.$emit</code></p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #03a9f4">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/setup/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/10/iconfont的使用/">
        <h2>
            Iconfont的使用
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/10
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="1-在线使用"><a href="#1-在线使用" class="headerlink" title="1.在线使用"></a>1.在线使用</h2><p><strong>1.Symbol-在线使用</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step1.png"></p>
<p><strong>2.选择Symbol方式引入，复制链接，然后在index.html文件中引入</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step2.png"></p>
<pre><code>&lt;script src=&quot;https://at.alicdn.com/t/c/font_3572742_w51elmyzq3.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><strong>3.加入通用css代码（引入一次即可）</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step3.png"></p>
<pre><code>.icon &#123;
  width: 1em;
  height: 1em;
  overflow: hidden;
  vertical-align: -0.15em;
  fill: currentColor;
&#125;
</code></pre>
<p>我放在了全局通用css文件里</p>
<p><strong>4.使用：挑选相应图标并获取类名，应用于页面</strong></p>
<pre><code>&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;
&lt;/svg&gt;
</code></pre>
<h2 id="2-Symbol-下载本地使用"><a href="#2-Symbol-下载本地使用" class="headerlink" title="2.Symbol-下载本地使用"></a>2.Symbol-下载本地使用</h2><p><strong>1.下载至本地</strong></p>
<p>****<img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step4.png"></p>
<p><strong>2.将其中的iconfont.js放到项目目录下，并在main.js中引入</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step7.png"></p>
<p><strong>3.通用css和使用与在线使用相同</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/css" style="color: #ff7d73">
                css
            </a>
        </span>
        
    </div>
    <a href="/2022/08/10/iconfont的使用/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/04/js循环/">
        <h2>
            Js循环
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/4
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>for循环</strong></p>
<p>for(初始化变量；条件表达式；操作表达式){</p>
<p>循环体</p>
<p>}</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/js" style="color: #ff7d73">
                js
            </a>
        </span>
        
    </div>
    <a href="/2022/08/04/js循环/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/03/js流程控制/">
        <h2>
            Js流程控制
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>流程控制：</strong></p>
<p><img src="/2022/08/03/js%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/lckz.jpg"></p>
<p><strong>if语句：</strong></p>
<p>if(条件表达式){</p>
<p>执行语句</p>
<p>}</p>
<p>如果条件成立则执行，否则什么也不做</p>
<p><strong>if else语句</strong></p>
<p>if(条件表达式){</p>
<p>执行语句</p>
<p>}else{</p>
<p>执行语句</p>
<p>}</p>
<p>条件成立，执行if里面的代码，否则执行else里面的代码</p>
<p><strong>多分支语句</strong></p>
<p>if(条件表达式){</p>
<p>}else if(条件表达式2){</p>
<p>}else</p>
<p><strong>三元表达式：</strong></p>
<p>条件表达式?语句1：语句2</p>
<p>条件表达式成立，值为1，否则为2</p>
<p>条件表达式1？语句1:条件表达式2?语句2:语句3</p>
<p>条件1成立，值为1，否则判断条件2，条件2成立，值为2，否则为3</p>
<p><strong>switch语句</strong></p>
<p>switch(条件表达式){</p>
<p>case  value1:</p>
<p>执行语句1；</p>
<p>break;</p>
<p>case  value2:</p>
<p>执行语句2；</p>
<p>break;</p>
<p>…</p>
<p>default:</p>
<p>执行最后的语句</p>
<p>}</p>
<p>当变量设置一系列特定值时，可以使用switch语句</p>
<p>var num&#x3D;3</p>
<p>switch(num){</p>
<p>case 1:</p>
<p>console.log(1)</p>
<p>break;</p>
<p>}</p>
<p>这里的num和case中的值匹配时必须全等，即num&#x3D;&#x3D;&#x3D;1</p>
<p>如果当前case中没有break，则不会退出switch,而是继续执行下一个case</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/js" style="color: #03a9f4">
                js
            </a>
        </span>
        
    </div>
    <a href="/2022/08/03/js流程控制/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/03/js算数运算符/">
        <h2>
            算数运算符
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>运算符：也被成为操作符，是用于实现赋值、比较和执行算数运算等功能的符号</p>
<p>算数运算符：+、-、*、&#x2F;、%(取余。9%2&#x3D;1)</p>
<p>浮点数的最高精度是17位小数，在进行计算时其精度远不如整数，如0.1+0.2&#x3D;0.30000000000000004，而不是0.3，所以不要直接判断两个浮点数是否相等</p>
<p>递增(++)、递减(–)运算符：根据在变量前还是后分为前置&#x2F;(后置)递增、递减运算符</p>
<p>前置：先加后用、后置：先用后加，自减同理</p>
<p>比较运算符:</p>
<p>&#x3D;：赋值</p>
<p>&#x3D;&#x3D;：判断左右两边值是否相等</p>
<p>&#x3D;&#x3D;&#x3D;：判断左右两边值和数据类型是否相等</p>
<p>逻辑运算：</p>
<p>短路运算：</p>
<p>逻辑与：表达式1&amp;&amp;表达式2，如果1为真则返回2，如果1为假，则返回1</p>
<p>逻辑或：表达式1||表达式2，如果1为真则返回1，如果1为假则返回2</p>
<p>运算优先级：</p>
<p><img src="/2022/08/03/js%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/yxj.jpg"></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/js" style="color: #00a596">
                js
            </a>
        </span>
        
    </div>
    <a href="/2022/08/03/js算数运算符/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/03/js数据类型/">
        <h2>
            Js数据类型
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/3
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>JavaScript是一种弱类型或者说动态语言，这意味这不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h3><p><strong>简单数据类型</strong>：</p>
<p>Number、Boolean、String、Undefined、Null</p>
<p>js中，8进制前面加0，16进制前面加0x</p>
<p><strong>isNaN()</strong>:</p>
<p>用来判断一个变量是否为非数字的类型，如果是，返回false，如果不是，返回true</p>
<p><strong>引号嵌套</strong>：</p>
<p>外双内单，外单内双</p>
<p><strong>typeof</strong>:</p>
<p>检测数据类型，typeof null 为object</p>
<p><strong>1.转换为字符串</strong>：</p>
<p>变量.toString()、String(变量)、+拼接 （变量+’字符串’，隐式转换）</p>
<p><strong>2.转换成数字</strong>：</p>
<ul>
<li><p>parseInt:parseInt(变量),转换为数字，得到的是整数（向下取整），parseInt(‘120px’)为120，会自动去掉单位</p>
</li>
<li><p>parseFloat:parseFloat(变量)，转换为数字，得到的是浮点数，会自动去掉单位</p>
</li>
<li><p>Number:Number(变量)，</p>
</li>
<li><p>利用算数运算(-，&#x2F;，*):’12’-0,’12’-‘12’</p>
</li>
</ul>
<p><strong>3.转换为布尔型:</strong></p>
<p>Boolean():代表空、否定的值会被转换为false,如：0，’’，NaN，null,undefined,其余值都会转换为true</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/js" style="color: #03a9f4">
                js
            </a>
        </span>
        
    </div>
    <a href="/2022/08/03/js数据类型/" class="go-post">
        阅读全文
    </a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            
            
            <span class="page-omit">...</span>
            <a href="/page/5">
                <span class="page-num">
                    5
                </span>
            </a>
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <svg class="fa-icon"><use xlink:href="#caret-right-solid"></use></svg>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://img.gejiba.com/images/39def1210a35239bb3777e2c504985f1.jpg " alt="avatar">
        </div>
        <div class="name">
            参商
        </div>
        <div class="descriptions">
            
            <div class="description">
                yyds
            </div>
            
        </div>
        <div class="icon-links">
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 mynote
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @参商
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>