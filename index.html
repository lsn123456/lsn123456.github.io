
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0">
        <title>Mynote</title>
        <meta name="author" content="参商">
        <meta name="description" content="个人笔记">
        <meta name="keywords" content="love&peace">
        <link rel="icon" href="https://img.gejiba.com/images/39def1210a35239bb3777e2c504985f1.jpg">
        <script src="https://cdn.staticfile.org/instant.page/5.1.0/instantpage.min.js" type="module"></script>
        <script src="https://cdn.staticfile.org/font-awesome/6.1.1/js/all.min.js"></script>
        <link rel="stylesheet" href="/css/fonts.min.css">
        <link rel="stylesheet" href="/css/particlex.css">
        <script src="https://cdn.staticfile.org/vue/3.2.33/vue.global.prod.min.js"></script>
    <meta name="generator" content="Hexo 6.2.0"></head>
    <body>
        <div id="loading" style="height:100vh;width:100vw;position:fixed;display:flex;z-index:200;justify-content:space-between;background:#fff;transition:opacity 0.3s ease-out"><div style="position:fixed;height:100vh;width:100vw;display:flex;justify-content:center;align-items:center"><div id="loadcontent" style="width:50vmin;height:50vmin;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px #a3ddfb;text-align:center"><div><h2>LOADING...</h2><p style="word-break:keep-all">加载过慢请开启缓存(浏览器默认开启)</p><div><img alt="loading" src="/loading.gif"></div></div></div></div></div>
        <div id="layout">
            <i data-fa-symbol="calendar-solid" class="fa-solid fa-calendar fa-fw"></i>
            <i data-fa-symbol="bookmark-solid" class="fa-solid fa-bookmark fa-fw"></i>
            <i data-fa-symbol="tags-solid" class="fa-solid fa-tags fa-fw"></i>
            <transition name="into">
                <div v-show="show_page" style="display: -not-none">
                    <div id="menu_show">
                         
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">mynote</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;about</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;tags</span>
        </a>
        
    </div>
    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div class="curtain" @click="menu_show = !menu_show" v-show="menu_show"></div>
        <div :class="'title'" @click="menu_show = !menu_show">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;mynote</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>
                    </div>
                    <div id="main">
                        <div id="home-head">
    <div id="home-background" style="background-image: url(https://img.gejiba.com/images/fb4fd20b295fa6af03f3d21094d319cb.jpg)"></div>
    
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>mynote</h1>
                <h3></h3>
                <h5>个人笔记</h5>
            </div>
        </span>
    </div>
    
</div>

<div id="home-posts-wrap" class=>
    <div id="home-posts">
        <div id="posts">
            

<div class="post">
    <a href="/2022/11/30/elementui日期选择器禁用日期/">
        <h2>
            Elementui日期选择器禁用日期
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/11/30
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>picker-options：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>shortcuts</td>
<td>设置快捷选项，需要传入 { text, onClick } 对象用法参考 demo 或下表</td>
<td>Object[]</td>
</tr>
<tr>
<td>disabledDate</td>
<td>设置禁用状态，参数为当前日期，要求返回 Boolean</td>
<td>Function</td>
</tr>
<tr>
<td>cellClassName</td>
<td>设置日期的 className</td>
<td>Function(Date)</td>
</tr>
<tr>
<td>firstDayOfWeek</td>
<td>周起始日</td>
<td>Number， 1 到 7，默认7</td>
</tr>
<tr>
<td>onPick</td>
<td>选中日期后会执行的回调，只有当 <code>daterange</code> 或 <code>datetimerange</code> 才生效</td>
<td>Function({ maxDate, minDate })</td>
</tr>
</tbody></table>
<p>这里通过<code>disabledDate</code>来设置禁用时间</p>
<p>今天之前的时间禁用：time.getTime() &lt; Date.now() - 8.64e7 </p>
<p>六个月后的时间禁用： time.getTime() &gt; new Date().getTime() + 3600 * 1000 * 24 * 180</p>
<p>3600秒  * 1000毫秒 * 24小时 * 180天，其他禁用天数一次类推</p>
<pre><code>              &lt;el-form-item label=&quot;承诺到款日期&quot; prop=&quot;contractNumber&quot;&gt;
                &lt;el-date-picker
                  v-model=&quot;form.promisePayDate&quot;
                  type=&quot;date&quot;
                  :picker-options=&quot;pickerOptions&quot;
                  placeholder=&quot;选择日期&quot;
                  style=&quot;width: 100%&quot;
                /&gt;
              &lt;/el-form-item&gt;
              
              data()&#123;
                  return&#123;
                       pickerOptions: &#123;
                       disabledDate: (time) =&gt; &#123;
                       return (
                       time.getTime() &gt; new Date().getTime() + 3600 * 1000 * 24 * 180 ||
                       time.getTime() &lt; Date.now() - 8.64e7
                     )
                    &#125;,
                   &#125;,
                  &#125;
              &#125;
</code></pre>
<p>禁用多时间：通过接口获取可以选择的时间，其他时间一律禁用</p>
<pre><code>                &lt;el-date-picker
                  v-model=&quot;form.reserveDate&quot;
                  type=&quot;date&quot;
                  style=&quot;width: 100%&quot;
                  placeholder=&quot;选择日期&quot;
                  :picker-options=&quot;pickerOptions&quot;
                  :disabled=&quot;isEdit&quot;
                  @change=&quot;changeDate&quot;
                /&gt;
                
                data()&#123;
                    return&#123;
                         pickerOptions:&#123;&#125;
                    &#125;
                &#125;
                
                methods:&#123;
                     async getDateList() &#123;
                     const res = await getReserveDateList(&#123;
                           pageNo: 1,
                           pageSize: -1,
                          &#125;)
                     //可以选择的时间范围
                     this.dateList = []
                     res.data.records.map((item) =&gt; &#123;
                       if (
                       parseTime(item.reserveDate, &#39;&#123;y&#125;-&#123;m&#125;-&#123;d&#125;&#39;) &gt;=
                       parseTime(new Date(), &#39;&#123;y&#125;-&#123;m&#125;-&#123;d&#125;&#39;)
                       ) &#123;
                         this.dateList.push(item.reserveDate)
                        &#125;
                       &#125;)

                       this.pickerOptions = Object.assign(&#123;&#125;, this.pickerOptions, &#123;
                       disabledDate: (time) =&gt; &#123;
                       //今日前的时间不可选择
                       let disabled = time.getTime() &lt; new Date().getTime() - 86400000
                       //在可选择的时间范围内的时间不禁用，其他时间禁用
                       let flag = true 
                       for (let i = 0; i &lt; this.dateList.length; i++) &#123;
                       if (
                            parseTime(time, &#39;&#123;y&#125;-&#123;m&#125;-&#123;d&#125;&#39;) ==
                            parseTime(this.dateList[i], &#39;&#123;y&#125;-&#123;m&#125;-&#123;d&#125;&#39;)
                          ) &#123;
                            flag = false
                          &#125;
                        &#125;

                     return disabled || flag
                     &#125;,
                   &#125;)
                     this.$forceUpdate()
                   &#125;,
                &#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/ElementUI" style="color: #00bcd4">
                ElementUI
            </a>
        </span>
        
    </div>
    <a href="/2022/11/30/elementui日期选择器禁用日期/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/11/08/TypeError-Cannot-read-properties-of-null-reading-level/">
        <h2>
            TypeError: Cannot Read Properties of Null (Reading Level)
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/categories/ElementUI">
                <span class="icon">
                    <svg class="fa-icon"><use xlink:href="#bookmark-solid"></use></svg>
                ElementUI
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/11/8
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>el-cascader 反复渲染报错</strong></p>
<p><img src="/2022/11/08/TypeError-Cannot-read-properties-of-null-reading-level/1.jpg"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>给组件设置 key（:key&#x3D;”resetCascader”），在data里面设置初始值为0，当组件数据发生变化时，监听改变这个 el-cascader 的 key 值（this.resetCascader++）</p>
<pre><code>       &lt;el-form-item prop=&quot;repairTypeTwo&quot; class=&quot;newFormItem&quot;&gt;
              &lt;span slot=&quot;label&quot; class=&quot;formTitle&quot;&gt;维修类别&lt;/span&gt;
              &lt;el-cascader
              :key=&quot;resetCascader&quot;//给组件设置 key
              v-model=&quot;form.repairTypeTwo&quot;
              style=&quot;width: 100%&quot;
              :options=&quot;repairTypeOneList&quot;
              filterable
              @change=&quot;handleTypeChange&quot;
             /&gt;
         &lt;/el-form-item&gt;
              
              
              
      data()&#123;
          return&#123;
             resetCascader: 0,
           &#125;
      &#125;
              
              
    watch: &#123;
      //el-cascader 反复渲染报错问题
      &#39;form.repairTypeTwo&#39;: &#123;
        deep: true,
        handler(newVal) &#123;
          this.resetCascader++
        &#125;,
      &#125;,
    &#125;,
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        
    </div>
    <a href="/2022/11/08/TypeError-Cannot-read-properties-of-null-reading-level/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/11/08/微信小程序/">
        <h2>
            
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/11/8
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h3 id="1-主体文件结构"><a href="#1-主体文件结构" class="headerlink" title="1. 主体文件结构"></a>1. 主体文件结构</h3><p>主体部分由三个文件组成，必须放在项目的根目录，如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必填</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/app.html">app.js</a></td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html">app.json</a></td>
<td>是</td>
<td>小程序公共设置( 严格的JSON语法，不能用单引号，不能写注释，否则编译报错 )</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html">app.wxss</a></td>
<td>否</td>
<td>小程序公共样式表( <strong>拓展了rpx尺寸单位，微信专属响应式像素</strong> )</td>
</tr>
</tbody></table>
<h3 id="2-页面文件结构"><a href="#2-页面文件结构" class="headerlink" title="2. 页面文件结构"></a>2. 页面文件结构</h3><p>页面由四个文件组成，分别是：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>必填</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html">js</a></td>
<td>是</td>
<td>页面逻辑 ( 微信小程序没有window和document对象 )</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/">wxml</a></td>
<td>是</td>
<td>页面结构  ( XML语法，不是HTML语法 )</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxss.html">wxss</a></td>
<td>否</td>
<td>页面样式表 ( <strong>拓展了rpx尺寸单位，微信专属响应式像素</strong> )</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pagejson">json</a></td>
<td>否</td>
<td>页面配置 ( 严格的JSON语法，不能用单引号，不能写注释，否则编译报错 )</td>
</tr>
</tbody></table>
<h3 id="3-其他文件"><a href="#3-其他文件" class="headerlink" title="3. 其他文件"></a>3. 其他文件</h3><p>project.config.json : 项目的配置文件</p>
<p>sitemap.json : 用来配置小程序及其页面是否允许被微信索引（上线的时候使用）</p>
<pre><code>&#123;
  &quot;rules&quot;:[&#123;
    &quot;action&quot;: &quot;allow&quot;,
    &quot;page&quot;: &quot;path/to/page&quot;
  &#125;, &#123;
    &quot;action&quot;: &quot;disallow&quot;,
    &quot;page&quot;: &quot;*&quot;
  &#125;]
&#125;
</code></pre>
<p>小程序启动过程：</p>
<p>1.把小程序的代码包下载到本地</p>
<p>2.解析app.json全局配置文件</p>
<p>3.执行app.js小程序入口文件，调用App()创建小程序实例</p>
<p>4.渲染小程序首页</p>
<p>5.小程序启动完成</p>
<p>页面渲染过程</p>
<p>1.加载解析页面的.json配置文件</p>
<p>2.加载页面的.wxml模板和.wxss样式</p>
<p>3.执行页面的.js文件，调用Page()创建页面实例</p>
<p>4.页面渲染完成</p>
<h2 id="2-微信小程序-app-json"><a href="#2-微信小程序-app-json" class="headerlink" title="2. 微信小程序-app.json"></a>2. 微信小程序-app.json</h2><h3 id="1-app-json-配置项列表"><a href="#1-app-json-配置项列表" class="headerlink" title="1. app.json 配置项列表"></a>1. app.json 配置项列表</h3><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html</a></p>
<pre><code class="javascript">&#123;
  &quot;pages&quot;: [
    &quot;pages/index/index&quot;,
    &quot;pages/logs/index&quot;
  ],
  &quot;window&quot;: &#123;
    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;
  &#125;,
  &quot;tabBar&quot;: &#123;
    &quot;color&quot;: &quot;#dddddd&quot;,
    &quot;selectedColor&quot;: &quot;#3cc51f&quot;,
    &quot;borderStyle&quot;: &quot;black&quot;,
    &quot;backgroundColor&quot;: &quot;#ffffff&quot;,
    &quot;list&quot;: [&#123;
      &quot;pagePath&quot;: &quot;page/component/index&quot;,
      &quot;iconPath&quot;: &quot;image/icon_component.png&quot;,
      &quot;selectedIconPath&quot;: &quot;image/icon_component_HL.png&quot;,
      &quot;text&quot;: &quot;组件&quot;
    &#125;, &#123;
      &quot;pagePath&quot;: &quot;page/API/index/index&quot;,
      &quot;iconPath&quot;: &quot;image/icon_API.png&quot;,
      &quot;selectedIconPath&quot;: &quot;image/icon_API_HL.png&quot;,
      &quot;text&quot;: &quot;接口&quot;
    &#125;]
  &#125;,
  &quot;networkTimeout&quot;: &#123;
    &quot;request&quot;: 10000,
    &quot;downloadFile&quot;: 10000
  &#125;,
  &quot;debug&quot;: true,
  &quot;navigateToMiniProgramAppIdList&quot;: [
    &quot;wxe5f52902cf4de896&quot;
  ]
&#125;

//如果要新增页面可以直接在pages里面编辑
</code></pre>
<blockquote>
<p><code>app.json</code>文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#pages">pages</a></td>
<td>String Array</td>
<td>是</td>
<td>设置页面路径</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#window">window</a></td>
<td>Object</td>
<td>否</td>
<td>设置默认页面的窗口表现</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar">tabBar</a></td>
<td>Object</td>
<td>否</td>
<td>设置底部 tab 的表现</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#debug">debug</a></td>
<td>Boolean</td>
<td>否</td>
<td>设置是否开启 debug 模式</td>
</tr>
<tr>
<td>style</td>
<td></td>
<td></td>
<td>设置样式版本</td>
</tr>
</tbody></table>
<h3 id="2-window配置"><a href="#2-window配置" class="headerlink" title="2 .window配置"></a>2 .window配置</h3><blockquote>
<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p>注意：页面的<code>.json</code>只能设置 <code>window</code> 相关的配置项，以决定本页面的窗口表现，所以无需写 <code>window</code> 这个键。</p>
</blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>navigationBarBackgroundColor</td>
<td>HexColor</td>
<td>#000000</td>
<td>导航栏背景颜色，如”#000000”</td>
</tr>
<tr>
<td>navigationBarTextStyle</td>
<td>String</td>
<td>white</td>
<td>导航栏标题颜色，仅支持 black&#x2F;white</td>
</tr>
<tr>
<td>navigationBarTitleText</td>
<td>String</td>
<td></td>
<td>导航栏标题文字内容</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>#ffffff</td>
<td>窗口的背景色，可以通过开启 “enablePullDownRefresh”:true来查看窗口颜色</td>
</tr>
<tr>
<td>backgroundTextStyle</td>
<td>String</td>
<td>dark</td>
<td>下拉刷新的背景字体、loading 图的样式，仅支持 dark&#x2F;light</td>
</tr>
<tr>
<td>enablePullDownRefresh</td>
<td>Boolean</td>
<td>false</td>
<td>是否开启下拉刷新，详见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">页面相关事件处理函数</a>。</td>
</tr>
<tr>
<td>onReachBottomDistance</td>
<td>Number</td>
<td>50</td>
<td>页面上拉触底事件触发时距页面底部距离，单位为px</td>
</tr>
</tbody></table>
<h3 id="3-tabBar"><a href="#3-tabBar" class="headerlink" title="3. tabBar"></a>3. tabBar</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar">https://mp.weixin.qq.com/debug/wxadoc/dev/framework/config.html#tabbar</a></p>
<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p><strong>Tip：</strong></p>
<ol>
<li>当设置 position 为 top 时，将不会显示 icon。</li>
<li>tabBar 中的 list 是一个数组，<strong>只能配置最少2个、最多5个 tab</strong>，tab 按数组的顺序排序。</li>
</ol>
<p><strong>属性说明：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab 上的文字默认颜色</td>
</tr>
<tr>
<td>selectedColor</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab 上的文字选中时的颜色</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>是</td>
<td></td>
<td>tab 的背景色</td>
</tr>
<tr>
<td>borderStyle</td>
<td>String</td>
<td>否</td>
<td>black</td>
<td>tabbar上边框的颜色， 仅支持 black&#x2F;white</td>
</tr>
<tr>
<td>list</td>
<td>Array</td>
<td>是</td>
<td></td>
<td>tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td>
</tr>
<tr>
<td>position</td>
<td>String</td>
<td>否</td>
<td>bottom</td>
<td>可选值 bottom、top，设置成top是无图标</td>
</tr>
</tbody></table>
<p>其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pagePath</td>
<td>String</td>
<td>是</td>
<td>页面路径，必须在 pages 中先定义</td>
</tr>
<tr>
<td>text</td>
<td>String</td>
<td>是</td>
<td>tab 上按钮文字</td>
</tr>
<tr>
<td>iconPath</td>
<td>String</td>
<td>否</td>
<td>图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效</td>
</tr>
<tr>
<td>selectedIconPath</td>
<td>String</td>
<td>否</td>
<td>选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td>
</tr>
</tbody></table>
<h3 id="4-页面配置–-json"><a href="#4-页面配置–-json" class="headerlink" title="4.页面配置–.json"></a>4.页面配置–.json</h3><p>在页面配置中，可以修改全局配置的部分信息，用来指定当前页面的一些特有配置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>navigationBarBackgroundColor</td>
<td>HexColor</td>
<td>#000000</td>
<td>导航栏背景颜色，如”#000000”</td>
</tr>
<tr>
<td>navigationBarTextStyle</td>
<td>String</td>
<td>white</td>
<td>导航栏标题颜色，仅支持 black&#x2F;white</td>
</tr>
<tr>
<td>navigationBarTitleText</td>
<td>String</td>
<td></td>
<td>导航栏标题文字内容</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>HexColor</td>
<td>#ffffff</td>
<td>窗口的背景色，可以通过开启 “enablePullDownRefresh”:true来查看窗口颜色</td>
</tr>
<tr>
<td>backgroundTextStyle</td>
<td>String</td>
<td>dark</td>
<td>下拉刷新的背景字体、loading 图的样式，仅支持 dark&#x2F;light</td>
</tr>
<tr>
<td>enablePullDownRefresh</td>
<td>Boolean</td>
<td>false</td>
<td>是否开启下拉刷新，详见<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E7%9B%B8%E5%85%B3%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0">页面相关事件处理函数</a>。</td>
</tr>
<tr>
<td>onReachBottomDistance</td>
<td>Number</td>
<td>50</td>
<td>页面上拉触底事件触发时距页面底部距离，单位为px</td>
</tr>
<tr>
<td>disableScroll</td>
<td>Boolean</td>
<td>false</td>
<td>设置为true则页面整体不能上下滚动，只在页面配置中有效，无法在app.json中设置该项</td>
</tr>
</tbody></table>
<h2 id="3-wxml语法"><a href="#3-wxml语法" class="headerlink" title="3.wxml语法"></a>3.wxml语法</h2><table>
<thead>
<tr>
<th></th>
<th>wxml</th>
<th>html</th>
</tr>
</thead>
<tbody><tr>
<td>标签名称</td>
<td>view,text,image,navigator</td>
<td>div,span,img,a</td>
</tr>
<tr>
<td>属性节点</td>
<td><code>&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;</code></td>
<td><code>&lt;navigator url=&quot;/apges/home/home&quot;&gt;超链接&lt;/navigator&gt;</code></td>
</tr>
</tbody></table>
<h2 id="4-样式"><a href="#4-样式" class="headerlink" title="4.样式"></a>4.样式</h2><p>   与 CSS 相比，WXSS 扩展的特性有： </p>
<ul>
<li><p>尺寸单位(rpx  rem)</p>
</li>
<li><p>vw和vh是css3中的新单位，是一种视窗单位，在小程序中同样适用</p>
</li>
<li><p>样式导入</p>
</li>
<li><p>提供了全局的样式和局部样式（项目根目录下的app.wxss会作用于所有小程序页面，局部页面的.wxss样式仅对当前页面生效）</p>
</li>
<li><p>wxss仅支持部分css选择器</p>
<h3 id="1-尺寸单位"><a href="#1-尺寸单位" class="headerlink" title="1.尺寸单位"></a>1.尺寸单位</h3><p><strong>1.rpx（responsive pixel）</strong>: </p>
<p>​      可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx &#x3D; 375px &#x3D; 750物理像素，1rpx &#x3D; 0.5px &#x3D; 1物理像素。</p>
<p><strong>2.vw和vh：</strong></p>
<p>​      是css3中的新单位，是一种视窗单位，在小程序中也同样适用。</p>
<p>小程序中，窗口宽度固定为100vw，将窗口宽度平均分成100份，1份是1vw</p>
<p>小程序中，窗口高度固定为100vh ，将窗口高度平均分成100份，1份是1vh</p>
<h3 id="2-样式引入"><a href="#2-样式引入" class="headerlink" title="2.样式引入"></a>2.样式引入</h3><p>使用<code>@import</code>语句可以导入外联样式表，<code>@import</code>后跟需要导入的外联样式表的相对路径，用<code>;</code>表示语句结束。</p>
<pre><code class="javascript">/** common.wxss **/
.small-p &#123;
  padding:5px;
&#125;

/** app.wxss **/
@import &quot;common.wxss&quot;;
.middle-p &#123;
  padding:15px;
&#125;

  .box2&#123;
      border: 1px solid red;
      width: 600rpx;
      height: 600rpx;
      /*background-image可以指定网络图片，但是不可以指定本地图片*/
      background-image: url(&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1586254613140&amp;di=33474e16f9fc5342f7a1e2be72f287f6&amp;imgtype=0&amp;src=http%3A%2F%2Fdmimg.5054399.com%2Fallimg%2Fpkm%2Fpk%2F22.jpg&quot;);
      /* background-image: url(../../icons/timg.jpg); */
  &#125;
</code></pre>
</li>
</ul>
<h3 id="3-选择器"><a href="#3-选择器" class="headerlink" title="3.选择器"></a>3.选择器</h3><p>  特别需要注意的是小程序 不支持通配符 * ，因此以下代码无效！</p>
<pre><code>
  *&#123;
    margin:0;
    padding:0;   
    box-sizing:border-box;
&#125;
</code></pre>
<p>  目前支持的选择器有：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>样例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.class</td>
<td>.container</td>
<td>选择所有拥有class&#x3D;”container”的组件</td>
</tr>
<tr>
<td>#id</td>
<td>#main</td>
<td>选择拥有id&#x3D;”main”的组件</td>
</tr>
<tr>
<td>element</td>
<td>view</td>
<td>选择所有view组件</td>
</tr>
<tr>
<td>element,element</td>
<td>view,text</td>
<td>选择所有文档的view组件和所有text组件</td>
</tr>
<tr>
<td>element element</td>
<td>view text</td>
<td>选择view 下的所有text组件</td>
</tr>
<tr>
<td>::after</td>
<td>view::after</td>
<td>在view组件后边插入内容</td>
</tr>
<tr>
<td>::before</td>
<td>view::before</td>
<td>在view组件前边插入内容</td>
</tr>
<tr>
<td>nth-child(n)</td>
<td>view:nth-child(n)</td>
<td>选择某个索引的标签</td>
</tr>
</tbody></table>
<h3 id="4-小程序中使用less"><a href="#4-小程序中使用less" class="headerlink" title="4.小程序中使用less"></a>4.小程序中使用less</h3><p>  原声小程序不支持 less ，其他基于小程序的框架基本都支持，如 wepy ， mpvue ， taro ，uni-app等。<br>  但是仅仅因为一个less功能，而去引用框架，肯定是不可取的。因此可以使用以下方式来实现</p>
<pre><code>1. 编辑器是 vscode
2. 安装插件 easy less
3. 在vs code的设置中加如下，配置
</code></pre>
<pre><code>
&#123;
    &quot;workbench.sideBar.location&quot;: &quot;left&quot;,
    &quot;less.compile&quot;: &#123;        
      &quot;outExt&quot;:&quot;.wxss&quot;
    &#125;
&#125;
</code></pre>
<ol start="4">
<li>在要编写样式的地方新建 less 文件，如 index.less ,然后正常编辑即可。</li>
</ol>
<h3 id="5-js文件分类"><a href="#5-js文件分类" class="headerlink" title="5.js文件分类"></a>5.js文件分类</h3><p>  <strong>1.app.js</strong>:</p>
<pre><code>是整个小程序项目的入口文件，通过调用App()函数来启动整个小程序
</code></pre>
<p>  <strong>2.页面的.js文件：</strong></p>
<p>  是页面的入口文件，通过调用Page()函数来创建并运行页面</p>
<p>  <strong>3.普通的.js文件：</strong></p>
<p>  普通的功能模块文件，用来封装公共的函数或属性供页面使用</p>
<p>  <strong>4.小程序不是运行在浏览器中，所以没有window和document对象</strong></p>
<pre><code>1.小程序不是运行在浏览器中，所以没有window和document对象
console.log(window);
console.log(document);

2.小程序js的一些额外成员
App(&#123;&#125;)方法：用于创建应用程序实例，指定应用程序的生命周期
Page()方法：用于创建页面对象
getApp()方法：用于获取全局的应用程序对象
getCurrentPages()方法：用于获取当前页面的调用栈 
   # https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html
wx : 微信小程序获取API的对象
</code></pre>
<p> <strong>5.import 和 include（小程序支持CommonJS规范）</strong></p>
<pre><code>1.小程序支持CommonJS规范
exports.aa 或者module.exports导出
require 引入

&lt;import src=&quot;a.wxml&quot;/&gt;   作用可以引入目标文件中定义的template，然后在当前的wxml中使用template。注意点不能使用引入目标文件中所引入的第三方的template，比如A import B,B import C，A可以使用B中声明的template，但是A不可以使用C中声明的template

&lt;include src=&quot;header.wxml&quot;/&gt;  作用可以引入目标文件中除了template wxs之外的所有代码
</code></pre>
<h2 id="wxs语法"><a href="#wxs语法" class="headerlink" title="wxs语法"></a>wxs语法</h2><p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p>
<p>wxml中无法调用在页面的<code>.js</code>中定义的函数，但是可以调用wxs中定义的函数。WXS存在的意义就是充当<code>computed/filter</code>这类功能。经常配合Musttache语法进行使用，但是不能作为组件的事件回调函数</p>
<p>wxs有自己的数据类型，wxs不支持es6语法,并且遵循CommonJS规范</p>
<p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。</p>
<p>WXS 代码可以编写在 wxml 文件中的 <code>&lt;wxs&gt;</code> 标签内，或以 <code>.wxs</code> 为后缀名的文件内。</p>
<p>wxs的运行环境和其他JavaScript代码是隔离的，wxs中不能调用js中定义的函数，也不能调用小程序中提供的API</p>
<p>在IOS设备上，小程序内的WXS会比JavaScript代码快2-20倍，但在android设备上，两者运行效率无差异</p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/">https://developers.weixin.qq.com/miniprogram/dev/reference/wxs/</a></p>
<pre><code class="javascript">&lt;!-- 声明一个wxs模块 : 不支持es6  需要指定模块的名字 module,方便在wxml中访问模块中的成员 --&gt;
&lt;wxs module=&quot;dateFormat&quot;&gt;
  //准备一个时间格式化的方法
  var format = function(date)&#123;
      //根据时间戳使用小程序提供的getDate()方法得到一个时间
      var time = getDate(date);
      var year = time.getFullYear();
      var month = time.getMonth() + 1;
      var date = time.getDate();
      var hour = time.getHours();
      var minute = time.getMinutes();
      var second = time.getSeconds();
      month = month &lt; 10 ? &quot;0&quot; + month : month;
      date = date &lt; 10 ? &quot;0&quot; + date : date;
      hour = hour &lt; 10 ? &quot;0&quot; + hour : hour;
      minute = minute &lt; 10 ? &quot;0&quot; + minute : minute;
      second = second &lt; 10 ? &quot;0&quot; + second : second;
      return year + &quot;-&quot; + month + &quot;-&quot; + date + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second;
  &#125;;

  var format2 = function(msg)&#123;
    var reg = getRegExp(&#39;小&#39;, &quot;g&quot;);
    return msg.replace(reg, &quot;大&quot;);
  &#125;

  var msg = &quot;hello world&quot;;

  //将外部需要使用的信息导出
  module.exports = &#123;
    format : format,
    format2:format2
    msg:msg
  &#125;
&lt;/wxs&gt;
&lt;text&gt;&#123;&#123;dateFormat.format(now)&#125;&#125;&lt;/text&gt;
&lt;text&gt;&#123;&#123;dateFormat.format2("小小的")&#125;&#125;&lt;/text&gt;
&lt;text&gt;&#123;&#123;dateFormat.msg&#125;&#125;&lt;/text&gt;
</code></pre>
<p>使用外联的wxs脚本</p>
<p>1.必须为<code>&lt;wxs&gt;</code>标签添加module和src属性</p>
<p>2.module用来指定模块的名称</p>
<p>3.src用来指定要引入的脚本的路径，且必须是相对路径</p>
<pre><code>utils/tools.wxs
var toLower = function (str) &#123;
  return str.toLowerCase();
&#125;;
module.exports = &#123;
  toLower: toLower,
&#125;;


    index.wxml中
    &lt;view&gt;
        &#123;&#123;m2.toLower('HH')&#125;&#125;
    &lt;/view&gt;
    &lt;wxs module=&quot;m2&quot; src=&quot;../../utils/index.wxs&quot; /&gt;
</code></pre>
<h1 id="5-wxml语法参考"><a href="#5-wxml语法参考" class="headerlink" title="5.wxml语法参考"></a>5.wxml语法参考</h1><p>1.数据绑定</p>
<p>WXML 中的动态数据均来自对应 Page 的 data。</p>
<p>简单绑定</p>
<p>数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：</p>
<p>内容</p>
<pre><code>&lt;view&gt; &#123;&#123; message &#125;&#125; &lt;/view&gt;
Page(&#123;
  data: &#123;
    message: &#39;Hello MINA!&#39;
  &#125;
&#125;)
</code></pre>
<h3 id="组件属性-需要在双引号之内"><a href="#组件属性-需要在双引号之内" class="headerlink" title="组件属性(需要在双引号之内)"></a>组件属性(需要在双引号之内)</h3><pre><code>&lt;view src=&quot;&#123;&#123;imgurl&#125;&#125;&quot;&gt; &lt;/view&gt;
Page(&#123;
  data: &#123;
    imgurl: &#39;/assets/imgs/icon-daokuanrenling.png&#39;
  &#125;
&#125;)
</code></pre>
<h3 id="控制属性-需要在双引号之内"><a href="#控制属性-需要在双引号之内" class="headerlink" title="控制属性(需要在双引号之内)"></a>控制属性(需要在双引号之内)</h3><pre><code>&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; &lt;/view&gt;
Page(&#123;
  data: &#123;
    condition: true
  &#125;
&#125;)
</code></pre>
<h3 id="关键字-需要在双引号之内"><a href="#关键字-需要在双引号之内" class="headerlink" title="关键字(需要在双引号之内)"></a>关键字(需要在双引号之内)</h3><p><code>true</code>：boolean 类型的 true，代表真值。</p>
<p><code>false</code>： boolean 类型的 false，代表假值。</p>
<p><strong>特别注意：</strong>不要直接写 checked&#x3D;”false”，其计算结果是一个字符串，转成 boolean 类型后代表真值。</p>
<pre><code>&lt;checkbox checked=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; &lt;/checkbox&gt;
</code></pre>
<h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><pre><code>&lt;view hidden=&quot;&#123;&#123;flag ? true : false&#125;&#125;&quot;&gt; Hidden &lt;/view&gt;
</code></pre>
<h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><pre><code>&lt;view&gt; &#123;&#123;a + b&#125;&#125; + &#123;&#123;c&#125;&#125; + d &lt;/view&gt;
Page(&#123;
  data: &#123;
    a: 1,
    b: 2,
    c: 3
  &#125;
&#125;)
view中的内容为 3 + 3 + d。
</code></pre>
<h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><pre><code>&lt;view wx:if=&quot;&#123;&#123;length > 5&#125;&#125;&quot;&gt; &lt;/view&gt;
</code></pre>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><pre><code>&lt;view&gt;&#123;&#123;"hello" + name&#125;&#125;&lt;/view&gt;
Page(&#123;
  data:&#123;
    name: &#39;MINA&#39;
  &#125;
&#125;)
</code></pre>
<h3 id="数据路径运算"><a href="#数据路径运算" class="headerlink" title="数据路径运算"></a>数据路径运算</h3><pre><code>&lt;view&gt;&#123;&#123;object.key&#125;&#125; &#123;&#123;array[0]&#125;&#125;&lt;/view&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    object: &#123;
      key: &#39;Hello &#39;
    &#125;,
    array: [&#39;MINA&#39;]
  &#125;
&#125;)
</code></pre>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>也可以在 Mustache 内直接进行组合，构成新的对象或者数组。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre><code>&lt;view wx:for=&quot;&#123;&#123;[zero, 1, 2, 3, 4]&#125;&#125;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    zero: 0
  &#125;
&#125;)
</code></pre>
<p>最终组合成数组<code>[0, 1, 2, 3, 4]</code>。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><pre><code>&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;for: a, bar: b&#125;&#125;&quot;&gt;&lt;/template&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    a: 1,
    b: 2
  &#125;
&#125;)
</code></pre>
<p>最终组合成的对象是 <code>&#123;for: 1, bar: 2&#125;</code></p>
<p>也可以用扩展运算符 <code>...</code> 来将一个对象展开</p>
<pre><code>&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;...obj1, ...obj2, e: 5&#125;&#125;&quot;&gt;&lt;/template&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    obj1: &#123;
      a: 1,
      b: 2
    &#125;,
    obj2: &#123;
      c: 3,
      d: 4
    &#125;
  &#125;
&#125;)
</code></pre>
<p>最终组合成的对象是 <code>&#123;a: 1, b: 2, c: 3, d: 4, e: 5&#125;</code>。</p>
<p>如果对象的 key 和 value 相同，也可以间接地表达。</p>
<pre><code>&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;foo, bar&#125;&#125;&quot;&gt;&lt;/template&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    foo: &#39;my-foo&#39;,
    bar: &#39;my-bar&#39;
  &#125;
&#125;)
</code></pre>
<p>最终组合成的对象是 <code>&#123;foo: &#39;my-foo&#39;, bar:&#39;my-bar&#39;&#125;</code>。</p>
<p><strong>注意</strong>：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：</p>
<pre><code>&lt;template is=&quot;objectCombine&quot; data=&quot;&#123;&#123;...obj1, ...obj2, a, c: 6&#125;&#125;&quot;&gt;&lt;/template&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    obj1: &#123;
      a: 1,
      b: 2
    &#125;,
    obj2: &#123;
      b: 3,
      c: 4
    &#125;,
    a: 5
  &#125;
&#125;)
</code></pre>
<p>最终组合成的对象是 <code>&#123;a: 5, b: 3, c: 6&#125;</code>。</p>
<p><strong>注意：</strong> 花括号和引号之间如果有空格，将最终被解析成为字符串</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;[1,2,3]&#125;&#125; &quot;&gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<p>等同于</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;[1,2,3] + ' '&#125;&#125;&quot;&gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h2><p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p>
<p>默认数组的当前项的下标变量名默认为 <code>index</code>，数组当前项的变量名默认为 <code>item</code></p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;
  &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;
&lt;/view&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    array: [&#123;
      message: &#39;foo&#39;,
    &#125;, &#123;
      message: &#39;bar&#39;
    &#125;]
  &#125;
&#125;)
</code></pre>
<p>使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，</p>
<p>使用 <code>wx:for-index</code> 可以指定数组当前下标的变量名：</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;array&#125;&#125;&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt;
  &#123;&#123;idx&#125;&#125;: &#123;&#123;itemName.message&#125;&#125;
&lt;/view&gt;
</code></pre>
<p><code>wx:for</code> 也可以嵌套，下边是一个九九乘法表</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item=&quot;i&quot;&gt;
  &lt;view wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item=&quot;j&quot;&gt;
    &lt;view wx:if=&quot;&#123;&#123;i <= j&#125;&#125;&quot;&gt; &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125;="&#123;&#123;i" j&#125;&#125; &lt; view&gt; < code></=></code></pre>
<h2 id="block-wx-for"><a href="#block-wx-for" class="headerlink" title="block wx:for"></a>block wx:for</h2><p>类似 <code>block wx:if</code>，也可以将 <code>wx:for</code> 用在<code>&lt;block/&gt;</code>标签上，以渲染一个包含多节点的结构块。例如：</p>
<pre><code>&lt;block wx:for=&quot;&#123;&#123;[1, 2, 3]&#125;&#125;&quot;&gt;
  &lt;view&gt; &#123;&#123;index&#125;&#125;: &lt;/view&gt;
  &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;
&lt;/block&gt;
</code></pre>
<h2 id="wx-key"><a href="#wx-key" class="headerlink" title="wx:key"></a>wx:key</h2><p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/input.html">input</a> 中的输入内容，<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component/switch.html">switch</a> 的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。（不需要用插值语法表示，直接使用即可）</p>
<p><code>wx:key</code> 的值以两种形式提供</p>
<ol>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</li>
<li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</li>
</ol>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p><strong>如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</strong></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/s/tpg5tKmv6kZt">在开发者工具中预览效果</a></p>
<pre><code>&lt;switch wx:for=&quot;&#123;&#123;objectArray&#125;&#125;&quot; wx:key=&quot;unique&quot; style=&quot;display: block;&quot;&gt; &#123;&#123;item.id&#125;&#125; &lt;/switch&gt;
&lt;button bindtap=&quot;switch&quot;&gt; Switch &lt;/button&gt;
&lt;button bindtap=&quot;addToFront&quot;&gt; Add to the front &lt;/button&gt;

&lt;switch wx:for=&quot;&#123;&#123;numberArray&#125;&#125;&quot; wx:key=&quot;*this&quot; style=&quot;display: block;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/switch&gt;
&lt;button bindtap=&quot;addNumberToFront&quot;&gt; Add to the front &lt;/button&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    objectArray: [
      &#123;id: 5, unique: &#39;unique_5&#39;&#125;,
      &#123;id: 4, unique: &#39;unique_4&#39;&#125;,
      &#123;id: 3, unique: &#39;unique_3&#39;&#125;,
      &#123;id: 2, unique: &#39;unique_2&#39;&#125;,
      &#123;id: 1, unique: &#39;unique_1&#39;&#125;,
      &#123;id: 0, unique: &#39;unique_0&#39;&#125;,
    ],
    numberArray: [1, 2, 3, 4]
  &#125;,
  switch: function(e) &#123;
    const length = this.data.objectArray.length
    for (let i = 0; i &lt; length; ++i) &#123;
      const x = Math.floor(Math.random() * length)
      const y = Math.floor(Math.random() * length)
      const temp = this.data.objectArray[x]
      this.data.objectArray[x] = this.data.objectArray[y]
      this.data.objectArray[y] = temp
    &#125;
    this.setData(&#123;
      objectArray: this.data.objectArray
    &#125;)
  &#125;,
  addToFront: function(e) &#123;
    const length = this.data.objectArray.length
    this.data.objectArray = [&#123;id: length, unique: &#39;unique_&#39; + length&#125;].concat(this.data.objectArray)
    this.setData(&#123;
      objectArray: this.data.objectArray
    &#125;)
  &#125;,
  addNumberToFront: function(e)&#123;
    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)
    this.setData(&#123;
      numberArray: this.data.numberArray
    &#125;)
  &#125;
&#125;)
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>当 <code>wx:for</code> 的值为字符串时，会将字符串解析成字符串数组</p>
<pre><code>&lt;view wx:for=&quot;array&quot;&gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<p>等同于</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;['a','r','r','a','y']&#125;&#125;&quot;&gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<p><strong>注意：</strong> 花括号和引号之间如果有空格，将最终被解析成为字符串</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;[1,2,3]&#125;&#125; &quot;&gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<p>等同于</p>
<pre><code>&lt;view wx:for=&quot;&#123;&#123;[1,2,3] + ' '&#125;&#125;&quot; &gt;
  &#123;&#123;item&#125;&#125;
&lt;/view&gt;
</code></pre>
<h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="wx-if"><a href="#wx-if" class="headerlink" title="wx:if"></a>wx:if</h2><p>在框架中，使用 <code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块：</p>
<pre><code>&lt;view wx:if=&quot;&#123;&#123;condition&#125;&#125;&quot;&gt; True &lt;/view&gt;
</code></pre>
<p>也可以用 <code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<pre><code>&lt;view wx:if=&quot;&#123;&#123;length > 5&#125;&#125;&quot;&gt; 1 &lt;/view&gt;
&lt;view wx:elif=&quot;&#123;&#123;length > 2&#125;&#125;&quot;&gt; 2 &lt;/view&gt;
&lt;view wx:else&gt; 3 &lt;/view&gt;
</code></pre>
<h2 id="block-wx-if"><a href="#block-wx-if" class="headerlink" title="block wx:if"></a>block wx:if</h2><p>因为 <code>wx:if</code> 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用 <code>wx:if</code> 控制属性。</p>
<pre><code>&lt;block wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;
  &lt;view&gt; view1 &lt;/view&gt;
  &lt;view&gt; view2 &lt;/view&gt;
&lt;/block&gt;
</code></pre>
<p><strong>注意：</strong> <code>&lt;block/&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h2 id="wx-if-vs-hidden"><a href="#wx-if-vs-hidden" class="headerlink" title="wx:if vs hidden"></a><code>wx:if</code> vs <code>hidden</code></h2><p><code>hidden</code>:   为true时隐藏，为false时显示</p>
<p>因为 <code>wx:if</code> 之中的模板也可能包含数据绑定，所以当 <code>wx:if</code> 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。</p>
<p>同时 <code>wx:if</code> 也是<strong>惰性的</strong>，如果在初始渲染条件为 <code>false</code>，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。</p>
<p>相比之下，<code>hidden</code> 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。</p>
<p>一般来说，<code>wx:if</code> 有更高的切换消耗而 <code>hidden</code> 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 <code>hidden</code> 更好，如果在运行时条件不大可能改变则 <code>wx:if</code> 较好。</p>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。</p>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><p>使用 name 属性，作为模板的名字。然后在<code>&lt;template/&gt;</code>内定义代码片段，如：</p>
<pre><code>&lt;!--
  index: int
  msg: string
  time: string
--&gt;
&lt;template name=&quot;msgItem&quot;&gt;
  &lt;view&gt;
    &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;
    &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;
  &lt;/view&gt;
&lt;/template&gt;
</code></pre>
<h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><p>使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如：</p>
<pre><code>&lt;template is=&quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot;/&gt;
</code></pre>
<pre><code>Page(&#123;
  data: &#123;
    item: &#123;
      index: 0,
      msg: &#39;this is a template&#39;,
      time: &#39;2016-09-15&#39;
    &#125;
  &#125;
&#125;)
</code></pre>
<p>is 属性可以使用 Mustache 语法，来动态决定具体需要渲染哪个模板：</p>
<pre><code>&lt;template name=&quot;odd&quot;&gt;
  &lt;view&gt; odd &lt;/view&gt;
&lt;/template&gt;
&lt;template name=&quot;even&quot;&gt;
  &lt;view&gt; even &lt;/view&gt;
&lt;/template&gt;

&lt;block wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;&quot;&gt;
  &lt;template is=&quot;&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;&quot;/&gt;
&lt;/block&gt;
</code></pre>
<h2 id="模板的作用域"><a href="#模板的作用域" class="headerlink" title="模板的作用域"></a>模板的作用域</h2><p>模板拥有自己的作用域，只能使用 data 传入的数据以及模板定义文件中定义的 <code>&lt;wxs /&gt;</code> 模块。</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>WXML 提供两种文件引用方式<code>import</code>和<code>include</code>。</p>
<h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><code>import</code>可以在该文件中使用目标文件定义的<code>template</code>，如：</p>
<p>在 item.wxml 中定义了一个叫<code>item</code>的<code>template</code>：</p>
<pre><code>&lt;!-- item.wxml --&gt;
&lt;template name=&quot;item&quot;&gt;
  &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;
&lt;/template&gt;
</code></pre>
<p>在 index.wxml 中引用了 item.wxml，就可以使用<code>item</code>模板：</p>
<pre><code>&lt;import src=&quot;item.wxml&quot;/&gt;
&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: 'forbar'&#125;&#125;&quot;/&gt;
</code></pre>
<h2 id="import-的作用域"><a href="#import-的作用域" class="headerlink" title="import 的作用域"></a>import 的作用域</h2><p>import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。</p>
<p><strong>如：C import B，B import A，在 C 中可以使用 B 定义的template，在 B 中可以使用 A 定义的template，但是 C 不能使用 A 定义的template</strong>。</p>
<pre><code>&lt;!-- A.wxml --&gt;
&lt;template name=&quot;A&quot;&gt;
  &lt;text&gt; A template &lt;/text&gt;
&lt;/template&gt;
</code></pre>
<pre><code>&lt;!-- B.wxml --&gt;
&lt;import src=&quot;a.wxml&quot;/&gt;
&lt;template name=&quot;B&quot;&gt;
  &lt;text&gt; B template &lt;/text&gt;
&lt;/template&gt;
</code></pre>
<pre><code>&lt;!-- C.wxml --&gt;
&lt;import src=&quot;b.wxml&quot;/&gt;
&lt;template is=&quot;A&quot;/&gt;  &lt;!-- Error! Can not use tempalte when not import A. --&gt;
&lt;template is=&quot;B&quot;/&gt;
</code></pre>
<h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p><code>include</code> 可以将目标文件<strong>除了</strong> <code>&lt;template/&gt;</code> <code>&lt;wxs/&gt;</code> 外的整个代码引入，相当于是拷贝到 <code>include</code> 位置，如：</p>
<pre><code>&lt;!-- index.wxml --&gt;
&lt;include src=&quot;header.wxml&quot;/&gt;
&lt;view&gt; body &lt;/view&gt;
&lt;include src=&quot;footer.wxml&quot;/&gt;
&lt;!-- header.wxml --&gt;
&lt;view&gt; header &lt;/view&gt;
&lt;!-- footer.wxml --&gt;
&lt;view&gt; footer &lt;/view&gt;
</code></pre>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h2><ul>
<li>事件是视图层到逻辑层的通讯方式。</li>
<li>事件可以将用户的行为反馈到逻辑层进行处理。</li>
<li>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。</li>
<li>事件对象可以携带额外信息，如 id, dataset, touches。</li>
</ul>
<h2 id="事件的使用方式"><a href="#事件的使用方式" class="headerlink" title="事件的使用方式"></a>事件的使用方式</h2><ul>
<li>在组件中绑定一个事件处理函数。</li>
</ul>
<p>如<code>bindtap</code>，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。</p>
<pre><code>&lt;view id=&quot;tapTest&quot; data-hi=&quot;Weixin&quot; bindtap=&quot;tapName&quot;&gt; Click me! &lt;/view&gt;
</code></pre>
<ul>
<li>在相应的 Page 定义中写上相应的事件处理函数，参数是event。</li>
</ul>
<pre><code>Page(&#123;
  tapName: function(event) &#123;
    console.log(event)
  &#125;
&#125;)
</code></pre>
<h3 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h3><p>事件分为冒泡事件和非冒泡事件：</p>
<ol>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ol>
<p>WXML的冒泡事件列表：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>触发条件</th>
<th>绑定方式</th>
</tr>
</thead>
<tbody><tr>
<td>touchstart</td>
<td>手指触摸动作开始</td>
<td></td>
</tr>
<tr>
<td>touchmove</td>
<td>手指触摸后移动</td>
<td></td>
</tr>
<tr>
<td>touchcancel</td>
<td>手指触摸动作被打断，如来电提醒，弹窗</td>
<td></td>
</tr>
<tr>
<td>touchend</td>
<td>手指触摸动作结束</td>
<td></td>
</tr>
<tr>
<td>tap</td>
<td>手指触摸后马上离开</td>
<td>bindtap或bind:tap</td>
</tr>
<tr>
<td>longpress</td>
<td>手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发</td>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a></td>
</tr>
<tr>
<td>longtap</td>
<td>手指触摸后，超过350ms再离开（推荐使用 longpress 事件代替）</td>
<td></td>
</tr>
<tr>
<td>transitionend</td>
<td>会在 WXSS transition 或 wx.createAnimation 动画结束后触发</td>
<td></td>
</tr>
<tr>
<td>animationstart</td>
<td>会在一个 WXSS animation 动画开始时触发</td>
<td></td>
</tr>
<tr>
<td>animationiteration</td>
<td>会在一个 WXSS animation 一次迭代结束时触发</td>
<td></td>
</tr>
<tr>
<td>animationend</td>
<td>会在一个 WXSS animation 动画完成时触发</td>
<td></td>
</tr>
<tr>
<td>touchforcechange</td>
<td>在支持 3D Touch 的 iPhone 设备，重按时会触发</td>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td>
</tr>
</tbody></table>
<p><strong>注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个组件)</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>绑定方式</th>
<th>事件描述</th>
</tr>
</thead>
<tbody><tr>
<td>tap</td>
<td>bindtap或bind:tap</td>
<td></td>
</tr>
<tr>
<td>input</td>
<td>bindinput或bind:input</td>
<td></td>
</tr>
<tr>
<td>change</td>
<td>bindchange或bind:change</td>
<td></td>
</tr>
</tbody></table>
<h3 id="普通事件绑定"><a href="#普通事件绑定" class="headerlink" title="普通事件绑定"></a>普通事件绑定</h3><p>事件绑定的写法类似于组件的属性，如：</p>
<pre><code>&lt;view bindtap=&quot;handleTap&quot;&gt;
    Click here!
&lt;/view&gt;
</code></pre>
<p>如果用户点击这个 view ，则页面的 <code>handleTap</code> 会被调用。</p>
<p>事件绑定函数可以是一个数据绑定，如：</p>
<pre><code>&lt;view bindtap=&quot;&#123;&#123; handlerName &#125;&#125;&quot;&gt;
    Click here!
&lt;/view&gt;
</code></pre>
<p>此时，页面的 <code>this.data.handlerName</code> 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。</p>
<p>自基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，在大多数组件和自定义组件中， <code>bind</code> 后可以紧跟一个冒号，其含义不变，如 <code>bind:tap</code> 。基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.8.1</a> 起，在所有组件中开始提供这个支持。</p>
<h3 id="绑定并阻止事件冒泡"><a href="#绑定并阻止事件冒泡" class="headerlink" title="绑定并阻止事件冒泡"></a>绑定并阻止事件冒泡</h3><p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p>
<p>例如在下边这个例子中，点击 inner view 会先后调用<code>handleTap3</code>和<code>handleTap2</code>(因为 tap 事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发<code>handleTap2</code>，点击 outer view 会触发<code>handleTap1</code>。</p>
<pre><code>&lt;view id=&quot;outer&quot; bindtap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; catchtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; bindtap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<h3 id="互斥事件绑定"><a href="#互斥事件绑定" class="headerlink" title="互斥事件绑定"></a>互斥事件绑定</h3><p>自基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.8.2</a> 起，除 <code>bind</code> 和 <code>catch</code> 外，还可以使用 <code>mut-bind</code> 来绑定事件。一个 <code>mut-bind</code> 触发后，如果事件冒泡到其他节点上，其他节点上的 <code>mut-bind</code> 绑定函数不会被触发，但 <code>bind</code> 绑定函数和 <code>catch</code> 绑定函数依旧会被触发。</p>
<p>换而言之，所有 <code>mut-bind</code> 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 <code>bind</code> 和 <code>catch</code> 的绑定效果。</p>
<p>例如在下边这个例子中，点击 inner view 会先后调用 <code>handleTap3</code> 和 <code>handleTap2</code> ，点击 middle view 会调用 <code>handleTap2</code> 和 <code>handleTap1</code> 。</p>
<pre><code>&lt;view id=&quot;outer&quot; mut-bind:tap=&quot;handleTap1&quot;&gt;
  outer view
  &lt;view id=&quot;middle&quot; bindtap=&quot;handleTap2&quot;&gt;
    middle view
    &lt;view id=&quot;inner&quot; mut-bind:tap=&quot;handleTap3&quot;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<h3 id="事件的捕获阶段"><a href="#事件的捕获阶段" class="headerlink" title="事件的捕获阶段"></a>事件的捕获阶段</h3><p>自基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a> 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用<code>capture-bind</code>、<code>capture-catch</code>关键字，后者将中断捕获阶段和取消冒泡阶段。</p>
<p>在下面的代码中，点击 inner view 会先后调用<code>handleTap2</code>、<code>handleTap4</code>、<code>handleTap3</code>、<code>handleTap1</code>。</p>
<pre><code>&lt;view id=&quot;outer&quot; bind:touchstart=&quot;handleTap1&quot; capture-bind:touchstart=&quot;handleTap2&quot;&gt;
  outer view
  &lt;view id=&quot;inner&quot; bind:touchstart=&quot;handleTap3&quot; capture-bind:touchstart=&quot;handleTap4&quot;&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<p>如果将上面代码中的第一个<code>capture-bind</code>改为<code>capture-catch</code>，将只触发<code>handleTap2</code>。</p>
<pre><code>&lt;view id=&quot;outer&quot; bind:touchstart=&quot;handleTap1&quot; capture-catch:touchstart=&quot;handleTap2&quot;&gt;
  outer view
  &lt;view id=&quot;inner&quot; bind:touchstart=&quot;handleTap3&quot; capture-bind:touchstart=&quot;handleTap4&quot;&gt;
    inner view
  &lt;/view&gt;
&lt;/view&gt;
</code></pre>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p><strong>BaseEvent 基础事件对象属性列表：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>基础库版本</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type">type</a></td>
<td>String</td>
<td>事件类型</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp">timeStamp</a></td>
<td>Integer</td>
<td>事件生成时的时间戳</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target">target</a></td>
<td>Object</td>
<td>触发事件的组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget">currentTarget</a></td>
<td>Object</td>
<td>当前组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark">mark</a></td>
<td>Object</td>
<td>事件标记数据</td>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.7.1</a></td>
</tr>
</tbody></table>
<p><strong>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#detail">detail</a></td>
<td>Object</td>
<td>额外的信息</td>
</tr>
</tbody></table>
<p><strong>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#touches">touches</a></td>
<td>Array</td>
<td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#changedTouches">changedTouches</a></td>
<td>Array</td>
<td>触摸事件，当前变化的触摸点信息的数组</td>
</tr>
</tbody></table>
<p><strong>特殊事件： canvas 中的触摸事件不可冒泡，所以没有 currentTarget。</strong></p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>代表事件的类型。</p>
<h3 id="timeStamp"><a href="#timeStamp" class="headerlink" title="timeStamp"></a>timeStamp</h3><p>页面打开到触发事件所经过的毫秒数。</p>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><p><strong>触发事件的源组件。</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>String</td>
<td>事件源组件的id</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td>
<td>Object</td>
<td>事件源组件上由<code>data-</code>开头的自定义属性组成的集合</td>
</tr>
</tbody></table>
<h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p><strong>事件绑定的当前组件。</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>String</td>
<td>当前组件的id</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td>
<td>Object</td>
<td>当前组件上由<code>data-</code>开头的自定义属性组成的集合</td>
</tr>
</tbody></table>
<p><strong>说明： target 和 currentTarget 可以参考上例中，点击 inner view 时，handleTap3 收到的事件对象 target 和 currentTarget 都是 inner，而 handleTap2 收到的事件对象 target 就是 inner，currentTarget 就是 middle。</strong></p>
<h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p>在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。</p>
<p>在 WXML 中，这些自定义数据以 <code>data-</code> 开头，多个单词由连字符 <code>-</code> 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：</p>
<ul>
<li><code>data-element-type</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementType</code> ；</li>
<li><code>data-elementType</code> ，最终会呈现为 <code>event.currentTarget.dataset.elementtype</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<pre><code>&lt;view data-alpha-beta=&quot;1&quot; data-alphaBeta=&quot;2&quot; bindtap=&quot;bindViewTap&quot;&gt; DataSet Test &lt;/view&gt;
</code></pre>
<pre><code>Page(&#123;
  bindViewTap:function(event)&#123;
    event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法
    event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写
  &#125;
&#125;)
</code></pre>
<h3 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h3><p>在基础库版本 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.7.1</a> 以上，可以使用 <code>mark</code> 来识别具体触发事件的 target 节点。此外， <code>mark</code> 还可以用于承载一些自定义数据（类似于 <code>dataset</code> ）。</p>
<p>当事件触发时，事件冒泡路径上所有的 <code>mark</code> 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 <code>mark</code> 。）</p>
<p><strong>代码示例：</strong></p>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/s/7LwTKvmi7woT">在开发者工具中预览效果</a></p>
<pre><code>&lt;view mark:myMark=&quot;last&quot; bindtap=&quot;bindViewTap&quot;&gt;
  &lt;button mark:anotherMark=&quot;leaf&quot; bindtap=&quot;bindButtonTap&quot;&gt;按钮&lt;/button&gt;
&lt;/view&gt;
</code></pre>
<p>在上述 WXML 中，如果按钮被点击，将触发 <code>bindViewTap</code> 和 <code>bindButtonTap</code> 两个事件，事件携带的 <code>event.mark</code> 将包含 <code>myMark</code> 和 <code>anotherMark</code> 两项。</p>
<pre><code>Page(&#123;
  bindViewTap: function(e) &#123;
    e.mark.myMark === &quot;last&quot; // true
    e.mark.anotherMark === &quot;leaf&quot; // true
  &#125;
&#125;)
</code></pre>
<p><code>mark</code> 和 <code>dataset</code> 很相似，主要区别在于： <code>mark</code> 会包含从触发事件的节点到根节点上所有的 <code>mark:</code> 属性值；而 <code>dataset</code> 仅包含一个节点的 <code>data-</code> 属性值。</p>
<p>细节注意事项：</p>
<ul>
<li>如果存在同名的 <code>mark</code> ，父节点的 <code>mark</code> 会被子节点覆盖。</li>
<li>在自定义组件中接收事件时， <code>mark</code> 不包含自定义组件外的节点的 <code>mark</code> 。</li>
<li>不同于 <code>dataset</code> ，节点的 <code>mark</code> 不会做连字符和大小写转换。</li>
</ul>
<h3 id="touches"><a href="#touches" class="headerlink" title="touches"></a>touches</h3><p>touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。</p>
<h4 id="Touch-对象"><a href="#Touch-对象" class="headerlink" title="Touch 对象"></a>Touch 对象</h4><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
</tr>
<tr>
<td>pageX, pageY</td>
<td>Number</td>
<td>距离文档左上角的距离，文档的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td>
</tr>
<tr>
<td>clientX, clientY</td>
<td>Number</td>
<td>距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴</td>
</tr>
</tbody></table>
<h4 id="CanvasTouch-对象"><a href="#CanvasTouch-对象" class="headerlink" title="CanvasTouch 对象"></a>CanvasTouch 对象</h4><table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody><tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
<td></td>
</tr>
<tr>
<td>x, y</td>
<td>Number</td>
<td>距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为 X 轴，纵向为 Y 轴</td>
<td></td>
</tr>
</tbody></table>
<h3 id="changedTouches"><a href="#changedTouches" class="headerlink" title="changedTouches"></a>changedTouches</h3><p>changedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
<h3 id="detail"><a href="#detail" class="headerlink" title="detail"></a>detail</h3><p>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见<a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/component">组件</a>定义中各个事件的定义。</p>
<p>点击事件的<code>detail</code> 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。</p>
<p><strong>事件绑定修改数据</strong></p>
<pre><code> bindtap=&quot;handleclick&quot;
 
 handleclick()&#123;
      this.setData(&#123;
      count: this.data.count + 1
    &#125;)
 &#125;
</code></pre>
<p><strong>事件传参</strong></p>
<p>小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数，因为小程序会把bindtap的属性值统一当作事件名称来处理。例如：下面代码将会被认为调用了一个名称为<code>toLink（item.link</code>）的函数，</p>
<pre><code> bindtap=&quot;toLink（item.link）&quot;
</code></pre>
<p>可以为组件提供<code>data-*</code>自定义属性传参，其中<code>*</code>代表的是参数的名字，示例如下</p>
<pre><code>    
bindtap=&quot;toLink&quot;
data-link=&quot;&#123;&#123;item.link&#125;&#125;&quot;

  toLink(e) &#123;
    console.log(&quot;点击了图标，要跳转页面&quot;, e.currentTarget.dataset.link)
  &#125;,
</code></pre>
<p><strong>bindinput的语法格式</strong></p>
<p>实现文本框和data之间的数据同步</p>
<pre><code>        &lt;input
             placeholder=&quot;请输入&quot;
             auto-focus
             bind:input=&quot;handleinput&quot;
             value=&quot;&#123;&#123;msg&#125;&#125;&quot;
    
        handleinput(e) &#123;
            this.setData(&#123;
            msg: e.detail.value
            &#125;)
         &#125;,
    
</code></pre>
<h1 id="网络数据请求"><a href="#网络数据请求" class="headerlink" title="网络数据请求"></a>网络数据请求</h1><p>跨域问题只存在于基于浏览器的Web开发中，小程序的宿主环境不是浏览器而是微信客户端，所以小程序中没有跨域问题</p>
<pre><code>wx.request(&#123;
  url: &#39;example.php&#39;, //请求地址
  method:&quot;get&quot;,//请求参数
  data: &#123;  //请求参数
    x: &#39;&#39;,
    y: &#39;&#39;
  &#125;,
  header: &#123; //设置请求头
    &#39;content-type&#39;: &#39;application/json&#39; // 默认值
  &#125;,
 dataType:&quot;json&quot;, //请求返回结果的数据类型
 success (res) &#123;//请求成功的回调
    console.log(res.data)
  &#125;，   
fail: function(res) &#123;&#125;,// 请求失败执行的回调函数
complete: function(res) &#123;&#125;,// 接口调用结束的回调函数（调用成功、失败都会执行）
&#125;)
</code></pre>
<h3 id="页面导航"><a href="#页面导航" class="headerlink" title="页面导航"></a>页面导航</h3><p>1.声明式导航</p>
<ul>
<li><p>在页面上生命一个<code>navigator</code>导航组件</p>
</li>
<li><p>通过点击<code>navigator</code>组件实现页面跳转</p>
</li>
<li><p>url表示要跳转的页面的地址,必须以&#x2F;开头；open-type表示跳转的方式，如tabbar页面必须用switchTab,默认为navigate</p>
</li>
<li><table>
<thead>
<tr>
<th>open-type</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>navigate</td>
<td>对应 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html">wx.navigateTo</a> 或 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html">wx.navigateToMiniProgram</a> 的功能</td>
<td>打开新页面，新页面会压栈</td>
</tr>
<tr>
<td>redirect</td>
<td>对应 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html">wx.redirectTo</a> 的功能</td>
<td>页面重定向，新页面不会压栈，而是把原来的页面替换掉</td>
</tr>
<tr>
<td>switchTab</td>
<td>对应 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html">wx.switchTab</a> 的功能</td>
<td>跳转tabBar页面，并关闭其他所有非 tabBar 页面</td>
</tr>
<tr>
<td>reLaunch</td>
<td>对应 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html">wx.reLaunch</a> 的功能</td>
<td>重新加载指定页面，页面全部出栈，只留下新的页面</td>
</tr>
<tr>
<td>navigateBack</td>
<td>对应 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html">wx.navigateBack</a> 或 <a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateBackMiniProgram.html">wx.navigateBackMiniProgram</a> （基础库 2.24.4 版本支持）的功能</td>
<td>回到上一个页面，通过delta指定回退的层数，默认值为1，当delta超出历史记录，返回首页</td>
</tr>
<tr>
<td>exit</td>
<td>退出小程序，<code>target=&quot;miniProgram&quot;</code>时生效</td>
<td></td>
</tr>
</tbody></table>
<p>​</p>
<pre><code>
   &lt;!--hover-class=&quot;none&quot; 跳转到Tabbar页面--&gt;
    &lt;navigator url=&quot;/pages/index/index&quot; open-type=&quot;switchTab&quot; &gt;跳转index&lt;/navigator&gt;
    &lt;!--hover-class=&quot;none&quot;后退导航--&gt;
    &lt;navigator url=&quot;/pages/index/index&quot; open-type=&quot;navigateBack&quot; delta=&quot;1&quot;&gt;跳转index&lt;/navigator&gt;
    &lt;view&gt;
    &lt;!--hover-class=&quot;none&quot; 导航传参--&gt;
   &lt;navigator url=&quot;/pages/demo2/demo2?name=zhangsan&amp;age=12&quot; hover-class=&quot;none&quot;&gt;跳转demo2&lt;/navigator&gt;
&lt;/view&gt;

//2.demo2.js
//在onload方法中通过options来获取页面1传递的参数
  onLoad: function (options) &#123;
    console.log(options)
  &#125;,
</code></pre>
<p>​</p>
</li>
</ul>
<p>2.编程式导航</p>
<pre><code>wx.navigateTo(&#123;
  url: &#39;/pagex/test/test?id=1&#39;,//导航传参
&#125;)
接收参数
onLoad(options)&#123;
    console.log(options)//options就是导航传递过来的参数
&#125;
</code></pre>
<h4 id="导航模式"><a href="#导航模式" class="headerlink" title="导航模式"></a>导航模式</h4><p>调用小程序的导航API实现页面的跳转</p>
<pre><code>&lt;view&gt;
   &lt;navigator url=&quot;/pages/demo2/demo2?name=zhangsan&amp;age=12&quot; open-type=&quot;redirectTo&quot; &gt;跳转demo2&lt;/navigator&gt;
&lt;/view&gt;

navigate   打开新页面，新页面会压栈
redirect    页面重定向，新页面不会压栈，而是把原来的页面替换掉
navigateBack   回到上一个页面
reLaunch    重新加载指定页面，页面全部出栈，只留下新的页面
switchTab   跳转tabBar页面，并关闭其他所有非 tabBar 页面

//  https://segmentfault.com/a/1190000014996318?utm_source=index-hottest


//注意点：
navigate, redirect 只能打开非 tabBar 页面。
switchTab 只能打开 tabBar 页面。
reLaunch 可以打开任意页面。

//回退两层，可以通过getCurrentPages()方法来查看栈中的页面个数
wx.navigateBack(&#123;
    //当delta超出历史记录，返回首页
    delta:2
&#125;)
</code></pre>
<h3 id="页面事件"><a href="#页面事件" class="headerlink" title="页面事件"></a>页面事件</h3><p>1.下拉刷新：移动端中手指在屏幕下滑从而重新加载页面数据</p>
<p>全局开启下拉刷新：在app.json的window节点中，将enablePullDownRefresh设置为true</p>
<p>局部开启下拉刷新（推荐）：在页面的json文件中将enablePullDownRefresh设置为true</p>
<pre><code>&#123;
  &quot;usingComponents&quot;: &#123;&#125;,
  &quot;enablePullDownRefresh&quot;:true,//开启下拉刷新
  &quot;backgroundColor&quot;:&quot;#D8BFD8&quot;,//窗口的背景色
  &quot;backgroundTextStyle&quot;:&quot;light&quot;//loading的样式颜色
&#125;
</code></pre>
<p>在js中的<code>onPullDownRefresh</code>中可以监听到下拉刷新的操作，在这里进行数据的处理，但是下拉刷新后刷新的loading会一直显示，需要调用<code> wx.stopPullDownRefresh()</code>停止下拉刷新的操作</p>
<p>2.上拉触底：移动端中手指在屏幕上滑从而重新加载更多数据，可以通过<code>onReachBottomDistance</code>来配置上拉触底触发事件的距离，默认为50px</p>
<p>在js中的<code>onReachBottom</code>中可以监听到上拉触底事件，这里应该进行节流的处理，上一个请求未处理完毕，不允许进行下一次请求</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>应用生命周期：小程序从启动&#x3D;&gt;运行&#x3D;&gt;销毁的过程</p>
<p>页面生命周期：每个页面加载&#x3D;&gt;渲染&#x3D;&gt;销毁的过程</p>
<p>页面的生命周期范围较小，应用生命周期的范围较大，可以在特定的时间点执行某些特定的操作</p>
<p>应用生命周期</p>
<pre><code>
onLaunch:function()&#123;&#125;//小程序初始化完成，会触发onLaunch(全局只触发一次)
onShow:function()&#123;&#125;//小程序启动，或从后台进入前台显示，会触发onShow
onHide:function()&#123;&#125;//小程序从前台进入后台，会触发onHide
</code></pre>
<p>页面生命周期</p>
<pre><code>onLoad:function(options)&#123;&#125;//监听页面加载，一个页面只调用一次
onShow:function()&#123;&#125;//监听页面显示
onReady:function()&#123;&#125;//监听页面初次渲染完成，一个页面只调用一次
onHide:function()&#123;&#125;//监听页面隐藏
onUnLoad:function()&#123;&#125;//监听页面卸载，一个页面只调用一次
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/微信小程序" style="color: #00bcd4">
                微信小程序
            </a>
        </span>
        
    </div>
    <a href="/2022/11/08/微信小程序/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/11/07/echarts的入门整理/">
        <h2>
            Echarts的入门整理
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/11/7
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1.安装方式"></a>1.安装方式</h2><pre><code>npm install echarts --save
</code></pre>
<h2 id="2-引入-ECharts"><a href="#2-引入-ECharts" class="headerlink" title="2.引入 ECharts"></a>2.引入 ECharts</h2><pre><code>import * as echarts from &#39;echarts&#39;;
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById(&#39;main&#39;));
// 绘制图表
myChart.setOption(&#123;
  title: &#123;
    text: &#39;ECharts 入门示例&#39;
  &#125;,
  tooltip: &#123;&#125;,
  xAxis: &#123;
    data: [&#39;衬衫&#39;, &#39;羊毛衫&#39;, &#39;雪纺衫&#39;, &#39;裤子&#39;, &#39;高跟鞋&#39;, &#39;袜子&#39;]
  &#125;,
  yAxis: &#123;&#125;,
  series: [
    &#123;
      name: &#39;销量&#39;,
      type: &#39;bar&#39;,
      data: [5, 20, 36, 10, 10, 20]
    &#125;
  ]
&#125;);
</code></pre>
<h2 id="3-图表容器及大小"><a href="#3-图表容器及大小" class="headerlink" title="3.图表容器及大小"></a>3.图表容器及大小</h2><h5 id="1-在-HTML-中定义有宽度和高度的父容器（推荐）"><a href="#1-在-HTML-中定义有宽度和高度的父容器（推荐）" class="headerlink" title="1.在 HTML 中定义有宽度和高度的父容器（推荐）"></a>1.在 HTML 中定义有宽度和高度的父容器（推荐）</h5><p>通常来说，需要在 HTML 中先定义一个 <code>&lt;div&gt;</code> 节点，并且通过 CSS 使得该节点具有宽度和高度。初始化的时候，传入该节点，图表的大小默认即为该节点的大小，除非声明了 <code>opts.width</code> 或 <code>opts.height</code> 将其覆盖。需要注意的是，使用这种方法在调用 <code>echarts.init</code> 时需保证容器已经有宽度和高度了。</p>
<pre><code>&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;));
&lt;/script&gt;
</code></pre>
<h5 id="2-指定图表的大小"><a href="#2-指定图表的大小" class="headerlink" title="2.指定图表的大小"></a>2.指定图表的大小</h5><p>如果图表容器不存在宽度和高度，或者，你希望图表宽度和高度不等于容器大小，也可以在初始化的时候指定大小。</p>
<pre><code>&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;), null, &#123;
    width: 600,
    height: 400
  &#125;);
&lt;/script&gt;
</code></pre>
<h5 id="3-响应容器大小的变化"><a href="#3-响应容器大小的变化" class="headerlink" title="3.响应容器大小的变化"></a>3.响应容器大小的变化</h5><p>监听图标容器的大小并改变图表大小</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
  var myChart = echarts.init(document.getElementById(&#39;main&#39;));
  window.onresize = function() &#123;
    myChart.resize();
  &#125;;
&lt;/script&gt;
</code></pre>
<h5 id="4-为图表设置特定的大小"><a href="#4-为图表设置特定的大小" class="headerlink" title="4.为图表设置特定的大小"></a>4.为图表设置特定的大小</h5><p>除了直接调用 <code>resize()</code> 不含参数的形式之外，还可以指定宽度和高度，实现图表大小不等于容器大小的效果。</p>
<pre><code>myChart.resize(&#123;
  width: 800,
  height: 400
&#125;);
</code></pre>
<h3 id="4-容器节点被销毁以及被重建时"><a href="#4-容器节点被销毁以及被重建时" class="headerlink" title="4.容器节点被销毁以及被重建时"></a>4.容器节点被销毁以及被重建时</h3><p>假设页面中存在多个标签页，每个标签页都包含一些图表。当选中一个标签页的时候，其他标签页的内容在 DOM 中被移除了。这样，当用户再选中这些标签页的时候，就会发现图表“不见”了。</p>
<p>本质上，这是由于图表的容器节点被移除导致的。即使之后该节点被重新添加，图表所在的节点也已经不存在了。</p>
<p>正确的做法是，在图表容器被销毁之后，调用 <a target="_blank" rel="noopener" href="https://echarts.apache.org/api.html#echartsInstance.dispose"><code>echartsInstance.dispose</code></a> 销毁实例，在图表容器重新被添加后再次调用 <a target="_blank" rel="noopener" href="https://echarts.apache.org//api.html#echarts.init">echarts.init</a> 初始化。</p>
<p>完整基础用法：</p>
<pre><code>    async mounted() &#123;
      window.addEventListener(&#39;resize&#39;, () =&gt; &#123;
        this.myChart.resize()
      &#125;)
    &#125;,
     //收支情况柱状图
      drawTotalChart() &#123;
        if (
          this.myChart != null &amp;&amp;
          this.myChart != &#39;&#39; &amp;&amp;
          this.myChart != undefined
        ) &#123;
          this.myChart.dispose()
        &#125;
        let chartDom = document.getElementById(&#39;totalmain&#39;)
        this.myChart = echarts.init(chartDom)

        let option = &#123;
          color: [&#39;rgba(96, 154, 240, 1)&#39;, &#39;rgba(107, 204, 212, 1)&#39;],
          tooltip: &#123;
            trigger: &#39;axis&#39;,
            axisPointer: &#123;
              type: &#39;shadow&#39;,
            &#125;,
          &#125;,
          grid: &#123;
            top: 50,
            left: 0,
            right: 0,
            bottom: 20,
            containLabel: true,
          &#125;,
          legend: &#123;
            data: [&#39;收入&#39;, &#39;支出&#39;],
            x: &#39;left&#39;,
            padding: [0, 0, 0, 0],
            itemStyle: &#123;&#125;,
          &#125;,
          xAxis: &#123;
            type: &#39;category&#39;,
            data: this.monthList,
          &#125;,
          yAxis: &#123;&#125;,
          series: [
            &#123; data: this.totalincome, type: &#39;bar&#39;, name: &#39;收入&#39; &#125;,
            &#123; data: this.totalspend, type: &#39;bar&#39;, name: &#39;支出&#39; &#125;,
          ],
        &#125;
        option &amp;&amp; this.myChart.setOption(option)
      &#125;,
    
</code></pre>
<h2 id="5-ECharts-中的样式"><a href="#5-ECharts-中的样式" class="headerlink" title="5.ECharts 中的样式"></a>5.ECharts 中的样式</h2><h5 id="1-颜色主题"><a href="#1-颜色主题" class="headerlink" title="1.颜色主题"></a>1.颜色主题</h5><ul>
<li>ECharts 中默认内置了两套主题: light dark。可以像这样切换成深色模式：</li>
</ul>
<pre><code>var chart = echarts.init(dom, &#39;dark&#39;);
</code></pre>
<ul>
<li><p>其他的主题，没有内置在 ECharts 中，需要自己加载</p>
</li>
<li><p>在echarts资源&#x2F;主题构建工具中下载需要的主题并引入,在echarts初始化时，使用主题。可以使用多个不同的主题。例如：</p>
</li>
</ul>
<p><code>let myChart = echarts.init(document.getElementById(&quot;School&quot;),&#39;macarons&#39;);</code></p>
<ul>
<li>注意：使用时不能自己指定color，否则主题的颜色将失效，变为指定的颜色</li>
</ul>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/1.jpg"></p>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/2.jpg"></p>
<pre><code>  import &#39;@/utils/purple-passion&#39;
  import &#39;@/utils/infographic&#39;
  
  let chartDom = document.getElementById(&#39;paymentMain&#39;)
  this.paymentMyChart = echarts.init(chartDom, &#39;infographic&#39;)
   
  let chartDom = document.getElementById(&#39;totalmain&#39;)
  this.myChart = echarts.init(chartDom, &#39;purple-passion&#39;)
</code></pre>
<h5 id="2-调色盘"><a href="#2-调色盘" class="headerlink" title="2.调色盘"></a>2.调色盘</h5><p>调色盘，可以在 option 中设置。它给定了一组颜色，图形、系列会自动从其中选择颜色。 可以设置全局的调色盘，也可以设置系列自己专属的调色盘。</p>
<pre><code>option = &#123;
  // 全局调色盘。
  color: [
    &#39;#c23531&#39;,
    &#39;#2f4554&#39;,
    &#39;#61a0a8&#39;,
    &#39;#d48265&#39;,
    &#39;#91c7ae&#39;,
    &#39;#749f83&#39;,
    &#39;#ca8622&#39;,
    &#39;#bda29a&#39;,
    &#39;#6e7074&#39;,
    &#39;#546570&#39;,
    &#39;#c4ccd3&#39;
  ],

  series: [
    &#123;
      type: &#39;bar&#39;,
      // 此系列自己的调色盘。
      color: [
        &#39;#dd6b66&#39;,
        &#39;#759aa0&#39;,
        &#39;#e69d87&#39;,
        &#39;#8dc1a9&#39;,
        &#39;#ea7e53&#39;,
        &#39;#eedd78&#39;,
        &#39;#73a373&#39;,
        &#39;#73b9bc&#39;,
        &#39;#7289ab&#39;,
        &#39;#91ca8c&#39;,
        &#39;#f49f42&#39;
      ]
      // ...
    &#125;,
    &#123;
      type: &#39;pie&#39;,
      // 此系列自己的调色盘。
      color: [
        &#39;#37A2DA&#39;,
        &#39;#32C5E9&#39;,
        &#39;#67E0E3&#39;,
        &#39;#9FE6B8&#39;,
        &#39;#FFDB5C&#39;,
        &#39;#ff9f7f&#39;,
        &#39;#fb7293&#39;,
        &#39;#E062AE&#39;,
        &#39;#E690D1&#39;,
        &#39;#e7bcf3&#39;,
        &#39;#9d96f5&#39;,
        &#39;#8378EA&#39;,
        &#39;#96BFFF&#39;
      ]
      // ...
    &#125;
  ]
&#125;;
</code></pre>
<h5 id="3-高亮的样式：emphasis"><a href="#3-高亮的样式：emphasis" class="headerlink" title="3.高亮的样式：emphasis"></a>3.高亮的样式：emphasis</h5><p>在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。但是高亮的样式也可以自己定义，主要是通过 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.emphasis">emphasis</a> 属性来定制。<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.emphasis">emphsis</a> 中的结构，和普通样式的结构相同，例如：</p>
<pre><code>         series: [
            &#123;
              name: &#39;报销&#39;,
              type: &#39;pie&#39;,
              radius: &#39;90%&#39;,
              hoverAnimation: false,
              emphasis: &#123;
                itemStyle: &#123;
                  // 高亮时点的颜色。
                  color: &#39;skyblue&#39;,
                &#125;,
                label: &#123;
                  show: true,
                  // 高亮时标签的文字。
                  formatter: &#39;This is a emphasis label.&#39;,
                &#125;,
              &#125;,
              label: &#123;
                normal: &#123;
                  show: true,
                  formatter: &#39;&#123;d&#125;%&#39;,
                  position: &#39;inner&#39;,
                  textStyle: &#123;
                    align: &#39;center&#39;,
                    baseline: &#39;middle&#39;,
                    fontFamily: &#39;微软雅黑&#39;,
                    fontSize: 14,
                    color: &#39;white&#39;,
                  &#125;,
                &#125;,
                labelLine: &#123;
                  show: false,
                &#125;,
              &#125;,
              data: this.data.reservationReimburseItemList,
            &#125;,
          ],
</code></pre>
<h5 id="4-直接的样式设置"><a href="#4-直接的样式设置" class="headerlink" title="4.直接的样式设置"></a>4.直接的样式设置</h5><p>直接的样式设置是比较常用设置方式。纵观 ECharts 的 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#">option</a> 中，很多地方可以设置 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.itemStyle">itemStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-line.lineStyle">lineStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-line.areaStyle">areaStyle</a>、<a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#series-bar.label">label</a> 等等。这些的地方可以直接设置图形元素的颜色、线宽、点的大小、标签的文字、标签的样式等等。上面的示例中已举例</p>
<h1 id="6-坐标轴"><a href="#6-坐标轴" class="headerlink" title="6.坐标轴"></a>6.坐标轴</h1><h5 id="1-x-轴、y-轴"><a href="#1-x-轴、y-轴" class="headerlink" title="1.x 轴、y 轴"></a>1.x 轴、y 轴</h5><p>x 轴和 y 轴都由轴线、刻度、刻度标签、轴标题四个部分组成。部分图表中还会有网格线来帮助查看和计算数据</p>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/3.jpg"></p>
<p>普通的二维数据坐标系都有 x 轴和 y 轴，通常情况下，x 轴显示在图表的底部，y 轴显示在左侧，一般配置如下：</p>
<pre><code>option = &#123;
  xAxis: &#123;
    // ...
  &#125;,
  yAxis: &#123;
    // ...
  &#125;
&#125;;
</code></pre>
<p>在二维数据中，轴也可以有多个。ECharts 中一般情况下单个 grid 组件最多只能放两个 x&#x2F;y 轴，多于两个 x&#x2F;y 轴需要通过配置 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#xAxis.offset">offset</a> 属性防止同个位置多个轴的重叠。两个 x 轴显示在上下，两个 y 轴显示在左右两侧。</p>
<pre><code>option = &#123;
  xAxis: &#123;
    type: &#39;time&#39;,
    name: &#39;销售时间&#39;
    // ...
  &#125;,
  yAxis: [
    &#123;
      type: &#39;value&#39;,
      name: &#39;销售数量&#39;
      // ...
    &#125;,
    &#123;
      type: &#39;value&#39;,
      name: &#39;销售金额&#39;
      // ...
    &#125;
  ]
  // ...
&#125;;
</code></pre>
<p>轴线：ECharts 提供了轴线 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#xAxis.axisLine">axisLine</a> 相关的配置，我们可以根据实际情况调整，例如轴线两端的箭头，轴线的样式等。</p>
<pre><code>option = &#123;
  xAxis: &#123;
    axisLine: &#123;
      symbol: &#39;arrow&#39;,
      lineStyle: &#123;
        type: &#39;dashed&#39;
        // ...
      &#125;
    &#125;
    // ...
  &#125;,
  yAxis: &#123;
    axisLine: &#123;
      symbol: &#39;arrow&#39;,
      lineStyle: &#123;
        type: &#39;dashed&#39;
        // ...
      &#125;
    &#125;
  &#125;
  // ...
&#125;;
</code></pre>
<p>刻度：ECharts 提供了轴线 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#xAxis.axisTick">axisTick</a> 相关的配置，我们可以根据实际情况调整，例如刻度线的长度，样式等。</p>
<pre><code>option = &#123;
  xAxis: &#123;
    axisTick: &#123;
      length: 6,
      lineStyle: &#123;
        type: &#39;dashed&#39;
        // ...
      &#125;
    &#125;
    // ...
  &#125;,
  yAxis: &#123;
    axisTick: &#123;
      length: 6,
      lineStyle: &#123;
        type: &#39;dashed&#39;
        // ...
      &#125;
    &#125;
  &#125;
  // ...
&#125;;
</code></pre>
<p>刻度标签：ECharts 提供了轴线 <a target="_blank" rel="noopener" href="https://echarts.apache.org/option.html#xAxis.axisLabel">axisLabel</a> 相关的配置，我们可以根据实际情况调整，例如文字对齐方式，自定义刻度标签内容等。</p>
<pre><code>option = &#123;
  xAxis: &#123;
    axisLabel: &#123;
      formatter: &#39;&#123;value&#125; kg&#39;,
      align: &#39;center&#39;
      // ...
    &#125;
    // ...
  &#125;,
  yAxis: &#123;
    axisLabel: &#123;
      formatter: &#39;&#123;value&#125; 元&#39;,
      align: &#39;center&#39;
      // ...
    &#125;
  &#125;
  // ...
&#125;;
</code></pre>
<p>示例：图左侧的 y 轴代表东京月平均气温，右侧的 y 轴表示东京降水量，x 轴表示时间。两组 y 轴在一起，反映了平均气温和降水量间的趋势关系。</p>
<pre><code>option = &#123;
  tooltip: &#123;
    trigger: &#39;axis&#39;,
    axisPointer: &#123; type: &#39;cross&#39; &#125;
  &#125;,
  legend: &#123;&#125;,
  xAxis: [
    &#123;
      type: &#39;category&#39;,
      axisTick: &#123;
        alignWithLabel: true
      &#125;,
      data: [
        &#39;1月&#39;,
        &#39;2月&#39;,
        &#39;3月&#39;,
        &#39;4月&#39;,
        &#39;5月&#39;,
        &#39;6月&#39;,
        &#39;7月&#39;,
        &#39;8月&#39;,
        &#39;9月&#39;,
        &#39;10月&#39;,
        &#39;11月&#39;,
        &#39;12月&#39;
      ]
    &#125;
  ],
  yAxis: [
    &#123;
      type: &#39;value&#39;,
      name: &#39;降水量&#39;,
      min: 0,
      max: 250,
      position: &#39;right&#39;,
      axisLabel: &#123;
        formatter: &#39;&#123;value&#125; ml&#39;
      &#125;
    &#125;,
    &#123;
      type: &#39;value&#39;,
      name: &#39;温度&#39;,
      min: 0,
      max: 25,
      position: &#39;left&#39;,
      axisLabel: &#123;
        formatter: &#39;&#123;value&#125; °C&#39;
      &#125;
    &#125;
  ],
  series: [
    &#123;
      name: &#39;降水量&#39;,
      type: &#39;bar&#39;,
      yAxisIndex: 0,
      data: [6, 32, 70, 86, 68.7, 100.7, 125.6, 112.2, 78.7, 48.8, 36.0, 19.3]
    &#125;,
    &#123;
      name: &#39;温度&#39;,
      type: &#39;line&#39;,
      smooth: true,
      yAxisIndex: 1,
      data: [
        6.0,
        10.2,
        10.3,
        11.5,
        10.3,
        13.2,
        14.3,
        16.4,
        18.0,
        16.5,
        12.0,
        5.2
      ]
    &#125;
  ]
&#125;;
</code></pre>
<p><img src="/2022/11/07/echarts%E7%9A%84%E5%85%A5%E9%97%A8%E6%95%B4%E7%90%86/4.jpg"></p>
<h2 id="7-事件与行为"><a href="#7-事件与行为" class="headerlink" title="7.事件与行为"></a>7.事件与行为</h2><p>在 Apache ECharts 的图表中用户的操作将会触发相应的事件。开发者可以监听这些事件，然后通过回调函数做相应的处理。在 ECharts 中事件分为两种类型，一种是用户鼠标操作点击，或者 hover 图表的图形时触发的事件，还有一种是用户在使用可以交互的组件后触发的行为事件，例如在切换图例开关时触发的 <a target="_blank" rel="noopener" href="https://echarts.apache.org/api.html#events.legendselectchanged">‘legendselectchanged’</a> 事件（这里需要注意切换图例开关是不会触发 <code>&#39;legendselected&#39;</code> 事件的），数据区域缩放时触发的 <a target="_blank" rel="noopener" href="https://echarts.apache.org/api.html#events.legendselectchanged">‘datazoom’</a> 事件等等。</p>
<h5 id="1-鼠标事件的处理"><a href="#1-鼠标事件的处理" class="headerlink" title="1.鼠标事件的处理"></a>1.鼠标事件的处理</h5><p>ECharts 支持常规的鼠标事件类型，包括 <code>&#39;click&#39;</code>、 <code>&#39;dblclick&#39;</code>、 <code>&#39;mousedown&#39;</code>、 <code>&#39;mousemove&#39;</code>、 <code>&#39;mouseup&#39;</code>、 <code>&#39;mouseover&#39;</code>、 <code>&#39;mouseout&#39;</code>、 <code>&#39;globalout&#39;</code>、 <code>&#39;contextmenu&#39;</code> 事件。</p>
<pre><code>myChart.on(&#39;click&#39;, function(params) &#123;
  window.open(&#39;https://www.baidu.com/s?wd=&#39; + encodeURIComponent(params.name));
&#125;);
</code></pre>
<p>所有的鼠标事件包含参数 <code>params</code>，这是一个包含点击图形的数据信息的对象，如下格式：</p>
<pre><code>type EventParams = &#123;
  // 当前点击的图形元素所属的组件名称，
  // 其值如 &#39;series&#39;、&#39;markLine&#39;、&#39;markPoint&#39;、&#39;timeLine&#39; 等。
  componentType: string;
  // 系列类型。值可能为：&#39;line&#39;、&#39;bar&#39;、&#39;pie&#39; 等。当 componentType 为 &#39;series&#39; 时有意义。
  seriesType: string;
  // 系列在传入的 option.series 中的 index。当 componentType 为 &#39;series&#39; 时有意义。
  seriesIndex: number;
  // 系列名称。当 componentType 为 &#39;series&#39; 时有意义。
  seriesName: string;
  // 数据名，类目名
  name: string;
  // 数据在传入的 data 数组中的 index
  dataIndex: number;
  // 传入的原始数据项
  data: Object;
  // sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，
  // dataType 的值会是 &#39;node&#39; 或者 &#39;edge&#39;，表示当前点击在 node 还是 edge 上。
  // 其他大部分图表中只有一种 data，dataType 无意义。
  dataType: string;
  // 传入的数据值
  value: number | Array;
  // 数据图形的颜色。当 componentType 为 &#39;series&#39; 时有意义。
  color: string;
&#125;;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/echarts" style="color: #00a596">
                echarts
            </a>
        </span>
        
    </div>
    <a href="/2022/11/07/echarts的入门整理/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/10/24/vue3中的watch和computed/">
        <h2>
            Vue3中的watch和computed
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/24
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="a-computed"><a href="#a-computed" class="headerlink" title="a) computed"></a>a) computed</h2><p>computed函数用来创造计算属性，和过去一样，它返回的值是一个ref对象。里面可以传方法，或者一个对象，对象中包含set()、get()方法</p>
<p><strong>只读的计算属性：</strong></p>
<pre><code class="javascript">  姓: &lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot; /&gt; &lt;br /&gt;
  名: &lt;input type=&quot;text&quot; v-model=&quot;person.lastName&quot; /&gt; &lt;br /&gt;
  &lt;span&gt;全名:&#123;&#123; person.fullName &#125;&#125;&lt;/span&gt;

import &#123; reactive, computed &#125; from &quot;vue&quot;;
setup() &#123;
    const person = reactive(&#123;
      firstName: &quot;张&quot;,
      lastName: &quot;三&quot;,
    &#125;);

    person.fullName = computed(() =&gt; &#123;
      return person.firstName + &quot;-&quot; + person.lastName;
    &#125;);

    return &#123; person &#125;;
  &#125;,
</code></pre>
<p><strong>可读可改的计算属性：</strong></p>
<pre><code class="javascript">   姓: &lt;input type=&quot;text&quot; v-model=&quot;person.firstName&quot; /&gt; &lt;br /&gt;
   名: &lt;input type=&quot;text&quot; v-model=&quot;person.lastName&quot; /&gt; &lt;br /&gt;
   全名：&lt;input type=&quot;text&quot; v-model=&quot;person.fullName&quot; /&gt; &lt;br /&gt;
   import &#123; reactive, computed &#125; from &quot;vue&quot;;
     setup() &#123;
    const person = reactive(&#123;
      firstName: &quot;张&quot;,
      lastName: &quot;三&quot;,
    &#125;);
    //完整形式
    person.fullName = computed(&#123;
      get() &#123;
        return person.firstName + &quot;-&quot; + person.lastName;
      &#125;,
      set(value) &#123;
        const nameArr = value.split(&quot;-&quot;);
        person.firstName = nameArr[0];
        person.lastName = nameArr[1];
      &#125;,
    &#125;);

    return &#123; person &#125;;
  &#125;,    
   
</code></pre>
<h2 id="b-watch"><a href="#b-watch" class="headerlink" title="b) watch"></a>b) watch</h2><p>与vue2中watch配置功能一致</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取，强制开启了深度监视（deep配置失效）</li>
<li>监视reactive定义的响应式数据中某个属性(对象)时，deep配置有效</li>
</ul>
<p> <strong>1.监视ref定义的一个响应式对象</strong></p>
<pre><code class="javascript"> let count = ref(0);
    let msg = ref(&quot;你好啊&quot;);

    const person = reactive(&#123;
      name: &quot;张三&quot;,
      age: 18,
      jobs: &#123;
        job1: &#123;
          salary: 20,
        &#125;,
      &#125;,
    &#125;);


    watch(count, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;count的值改变了&quot;, newVal, oldVal);
    &#125;);
</code></pre>
<p> <strong>2.监视ref定义的多个响应式对象</strong></p>
<pre><code>   watch(
      [count, msg],
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;count或者msg的数据改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; immediate: true, deep: true &#125;
    );
    
    
</code></pre>
<p><strong>3.监视reactive定义的响应式对象的全部属性,但是这里无法正确的获取oldVal,强制开启了深度监视(deep配置无效)</strong></p>
<pre><code>  watch(person, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person改变了&quot;, newVal, oldVal);
    &#125;,&#123;deep:false&#125;);//deep配置无效
</code></pre>
<p><strong>4.监视reactive定义的响应式数据的一个属性，这种方式可获取oldVal</strong></p>
<pre><code> watch(
      () =&gt; person.age,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的age改变了&quot;, newVal, oldVal);
      &#125;
    );
</code></pre>
<p><strong>5.监视reactive定义的响应式数据的某些属性,这种方式可获取oldVal</strong></p>
<pre><code>    watch([() =&gt; person.age, () =&gt; person.name], (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person的age或name改变了&quot;, newVal, oldVal);
    &#125;);
</code></pre>
<p><strong>6.特殊情况，监视reactive定义的响应式对象中的某个对象,这里deep配置有效，获取不到oldVal</strong></p>
<pre><code>    watch(
      () =&gt; person.jobs,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的job改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; deep: true &#125;
    );
</code></pre>
<p><strong>7.ref定义的响应式对象</strong></p>
<p>如果定义的对象是基本数据，则不用加<code>.value</code>,例如<code> let count=ref(0)</code>,如果在监视时加了<code>.value</code>，则监视的则是0这个数字，不是我们想要的refImpl数据对象，如果定义的对象是一个对象，则需要加<code>.value</code>，否则监听时虽然对象内的数据改变，但整个对象没有改变（其内存地址没有发生变化），会认为没有发生变化，也就监听不到对象内数据的变化</p>
<pre><code>    const person = ref(&#123;
      name: &quot;张三&quot;,
      age: 18,
      jobs: &#123;
        job1: &#123;
          salary: 20,
        &#125;,
      &#125;,
    &#125;);



1.数据为对象时，需要加.value
 watch(person.value, (newVal, oldVal) =&gt; &#123;
      console.log(&quot;person的值改变了&quot;, newVal, oldVal);
    &#125;);
2.若不加.value，则需要深度监听(deep:true)，才能监听到对象的改变
    watch(
      person,
      (newVal, oldVal) =&gt; &#123;
        console.log(&quot;person的值改变了&quot;, newVal, oldVal);
      &#125;,
      &#123; deep: true &#125;
    );
</code></pre>
<h1 id="watch和watchEffect"><a href="#watch和watchEffect" class="headerlink" title="watch和watchEffect"></a>watch和watchEffect</h1><h4 id="a-纯函数与副作用"><a href="#a-纯函数与副作用" class="headerlink" title="a) 纯函数与副作用"></a>a) 纯函数与副作用</h4><p>effect全称叫side effect，副作用。</p>
<p>什么是副作用呢，一个函数运行后产生了可以影响其外部或可以看到的效果，就叫副作用，比如document. Body. Append，alert再或者是showModel（在页面中展示一个弹层），或者window.open打开一个新窗口。<br><img src="/2022/10/24/vue3%E4%B8%AD%E7%9A%84watch%E5%92%8Ccomputed/%E8%AF%BE%E4%BB%B6/19.Vue3%E8%BF%9B%E9%98%B6&vite/19.Vue3%E8%BF%9B%E9%98%B6&vite/readme/assets/Snipaste_2021-11-23_10-58-18.jpg" alt="Snipaste_2021-11-23_10-58-18"></p>
<pre><code class="javascript">// 纯函数：如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。它不应修改程序的状态或引起副作用。
function priceAfterTax(productPrice) &#123; 
    return (productPrice * 0.20) + productPrice;
&#125;

// 副作用：一个可以被观察的副作用是在函数内部与其外部的任意交互。这可能是在函数内修改外部的变量，或者在函数里调用另外一个函数等。
var tax = 20;
function calculateTax(productPrice) &#123;
    tax = tax/100
    return (productPrice * tax) + productPrice;
&#125;
</code></pre>
<ul>
<li><p>react中副作用可以这样理解：组件初始化的时候，组件根据开发者的设定，由自身驱动的第一次DOM修改，就是主作用。主作用之后，组件开始执行用户逻辑，这时你眼里的业务逻辑代码，在React眼里都是副作用。</p>
</li>
<li><p>vue3中的副作用与react中副作用的定义类似，响应式数据的变更造成的其他连锁反应，以及后续逻辑，这些连锁反应都叫副作用。</p>
</li>
</ul>
<p>哪些函数没有副作用呢，只用来计算结果的函数，比如Math.max，JSON.parse，它们的运行除了返回结果外不会有其它效果，这就叫不产生副作用。</p>
<p>基本上可以简化的理解为副作用就是执行某种操作(副作用函数)，无副作用就是执行某种计算(纯函数)。</p>
<p>这里watchEffect的意思就是在观察（watch）到变化后执行一些操作（effect）。</p>
<h4 id="b-watchEffect的基本使用"><a href="#b-watchEffect的基本使用" class="headerlink" title="b) watchEffect的基本使用"></a>b) watchEffect的基本使用</h4><pre><code class="javascript">import &#123; watchEffect, ref &#125; from &#39;vue&#39;
setup () &#123;
    const userID = ref(0)
    
    watchEffect(() =&gt; console.log(userID))
    
    setTimeout(() =&gt; &#123;
      userID.value = 1
    &#125;, 1000)

    return &#123;
      userID
    &#125;
 &#125;
</code></pre>
<h4 id="c-watch和watchEffect的异同"><a href="#c-watch和watchEffect的异同" class="headerlink" title="c) watch和watchEffect的异同"></a>c) watch和watchEffect的异同</h4><p>watch和watchEffect都可以侦听副作用，区别在于：</p>
<ul>
<li>第一点我们可以从示例代码中看到 <code>watchEffect</code> 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行；而 <code>watch</code> 只能监听指定的属性而做出变更。</li>
<li>第二点就是 watch 可以获取到新值与旧值（更新前的值），而 <code>watchEffect</code> 是拿不到的。</li>
<li>第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与<code>computed</code>同理），而后收集到的依赖发生变化，这个回调才会再次执行；而 watch 不需要，因为他一开始就指定了依赖。</li>
</ul>
<h4 id="d-watchEffect的刷新时机"><a href="#d-watchEffect的刷新时机" class="headerlink" title="d) watchEffect的刷新时机"></a>d) watchEffect的刷新时机</h4><p>watchEffect会在所有的组件 <code>update</code> <strong>前</strong>执行。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  setup() &#123;
    const count = ref(0)

    watchEffect(() =&gt; &#123;
      console.log(count.value)
    &#125;)

    return &#123;
      count
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>在这个例子中：</p>
<ul>
<li><code>count</code> 会在初始运行时同步打印出来，因为watchEffect会在组件初始化的时候默认收集一次依赖</li>
<li>更改 <code>count</code> 时，将在组件<strong>更新前</strong>执行副作用。</li>
</ul>
<p>如果需要在组件更新(例如：当与<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-template-refs.html#%E4%BE%A6%E5%90%AC%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8">模板引用</a>一起)<strong>后</strong>重新运行侦听器副作用，我们可以传递带有 <code>flush</code> 选项的附加 <code>options</code> 对象 (默认为 <code>&#39;pre&#39;</code>)：</p>
<pre><code class="javascript">watchEffect(
  () =&gt; &#123;
    /* ... */
  &#125;,
  &#123;
    flush: &#39;post&#39;
  &#125;
)
</code></pre>
<h4 id="e-停止侦听"><a href="#e-停止侦听" class="headerlink" title="e) 停止侦听"></a>e) 停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup()</a> 函数或<a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html">生命周期钩子</a>被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p>
<p>在一些情况下，也可以显式调用返回值以停止侦听：</p>
<pre><code class="javascript">const stop = watchEffect(() =&gt; &#123;
  /* ... */
&#125;)

stop()
</code></pre>
<h4 id="f-清除副作用的函数"><a href="#f-清除副作用的函数" class="headerlink" title="f) 清除副作用的函数"></a>f) 清除副作用的函数</h4><p>watchEffect函数的onInvalidate方法就是用来清除副作用的，但副作用不一定是不被需要的。它可以是获取数据、事件监听或订阅、改变应用状态、修改 DOM、输出日志等等。清除副作用实际上是Vue3提供给用户的一种取消异步副作用的实现方法。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;
    &lt;button @click=&quot;doAdd&quot;&gt;点我+1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, watchEffect, watch &#125; from &quot;vue&quot;;

export default &#123;
  setup() &#123;
    const count = ref(1);

    const doAdd = ()=&gt;&#123;
      count.value++
    &#125;

    watchEffect(onInvalidate =&gt; &#123;
      console.log(count.value)
      // 异步api调用，返回一个操作对象
      const timer = setInterval(() =&gt; &#123;
        console.log(&quot;timer执行了&quot;)
      &#125;, 1000);

      //onInvalidate(fn)传入的回调会在watchEffect重新运行或者watchEffect停止的时候执行。
      onInvalidate(()=&gt;&#123;
        clearInterval(timer)
      &#125;)
    &#125;);

    return &#123;
      count,
      doAdd
    &#125;;
  &#125;
&#125;;
&lt;/script&gt;
</code></pre>
<h3 id><a href="#" class="headerlink" title></a></h3>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #00bcd4">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/10/24/vue3中的watch和computed/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/10/18/vue3中的响应式原理/">
        <h2>
            Vue3中的响应式原理
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/10/18
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>vue2.x的响应式：</p>
<p>实现原理：</p>
<p>对象类型：通过<code>Object.definProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截（对数组的变更方法进行了包裹）</p>
<pre><code>Objet.defineProperty(data,&#39;count&#39;,&#123;
    get()&#123;&#125;,
    set()&#123;&#125;
&#125;)
</code></pre>
<p>存在问题：</p>
<p>新增属性、删除属性，界面不会更新</p>
<p>直接通过下标修改数组，界面不会自动更新</p>
<p>vue3.x的响应式</p>
<p>实现原理：</p>
<p>通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的增加、属性的删除等</p>
<p>通过Reflect  (反射)  ：对源对象的属性进行操作</p>
<p>模拟vue3中实现响应式</p>
<pre><code>//源数据
let person=&#123;
    name:&#39;张三&#39;,
    age:18
&#125;
const p=new Proxy(person,&#123;
    //有人读取p的某个属性时调用
    get(target,propName)&#123;
    console.log(`有人读取了p身上的$&#123;propName&#125;属性`)
    return Reflect.get(target,propName)
    &#125;，
    //有人修改p的某个属性、或给p追加某个属性时调用
    set(target,propName,value)&#123;
    console.log(`有人修改了了p身上的$&#123;propName&#125;属性`)
    Reflect.set(target,propName,value)
    &#125;,
    //有人删除p的某个属性时调用
    deleteProperty(target,propName)&#123;
    console.log(`有人删除了p身上的$&#123;propName&#125;属性`)
    return Reflect.deleteProperty(target,peopName)
    &#125;，
&#125;)
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ffa2c4">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/10/18/vue3中的响应式原理/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/09/26/ref与reactive/">
        <h2>
            Ref与reactive
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h3 id="1-ref"><a href="#1-ref" class="headerlink" title="1. ref"></a>1. ref</h3><p>ref 用于为数据添加响应式状态，可以让某一个变量具备响应式的能力。由于reactive只能传入对象类型的参数，<strong>而对于基本数据类型要添加响应式状态就只能用ref了，同样返回一个具有响应式状态的副本。</strong></p>
<ul>
<li>在 js 中使用 ref 的值必须使用 .value 获取，在 Vue 的模板中使用 ref 的值不需要通过 value 获取</li>
<li>语法：const xxx&#x3D;ref(initValue),创建了一个包含响应式数据的引用对象</li>
<li>接收的数据可以是：基本类型、对象类型，对于基本数据类型，ref是自己的实现方式且性能优于reactive；而对于对象类型，ref仍然是通过reactive包装实现的</li>
<li>参数可以传递任意数据类型，传递对象类型时也能保持深度响应式，所以适用性更广。</li>
<li>vue 3.0 setup里定义数据时推荐优先使用ref，方便逻辑拆分和业务解耦。</li>
</ul>
<pre><code class="javascript">import &#123; ref &#125; from &quot;vue&quot;;

setup() &#123;
    const msg = &quot;张晓明&quot;;
    let age = ref(18);
    function add() &#123;
      age.value += 1;
    &#125;
    return &#123; msg, age, add &#125;;
&#125;
</code></pre>
<h3 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2. reactive"></a>2. reactive</h3><p>经过reactive函数处理后的对象能变成响应式的对象，类似于option api里面的data属性的值，<strong>它主要是处理你的对象让它经过 <code>Proxy</code> 的加工变为一个响应式的对象。</strong></p>
<p><strong>注意点：</strong></p>
<ul>
<li><p>语法：<code>const 代理对象=reactive(源对象)</code>,接收一个对象(或数组),返回一个代理对象(proxy对象)</p>
</li>
<li><p>如果想要保持对象内容的响应式能力，在 return 的时候必须把整个 <code>reactive()</code> 对象返回出去</p>
</li>
<li><p>在引用的时候也必须对整个对象进行引用而无法解构，否则这个对象内容的响应式能力将会丢失。</p>
</li>
<li><p><code>reactive()</code>只能包装对象,基本类型不要用它，要用ref函数</p>
</li>
<li><p>reactive定义的响应式数据是深层次的，内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作</p>
</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; state.name &#125;&#125; 价格:&#123;&#123; state.price &#125;&#125;
    购买数量:&#123;&#123;state.count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      state.count += 1;
    &#125;
    return &#123; state, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="3-isRef-amp-toRefs-amp-toRef"><a href="#3-isRef-amp-toRefs-amp-toRef" class="headerlink" title="3. isRef &amp; toRefs &amp; toRef"></a>3. isRef &amp; toRefs &amp; toRef</h3><h4 id="a-isRef"><a href="#a-isRef" class="headerlink" title="a) isRef"></a>a) isRef</h4><p>用来判断某个值是否为ref创建出来的对象。</p>
<pre><code class="javascript">import &#123; ref, isRef &#125; from &#39;vue&#39;;
export default &#123;
    setup () &#123;
        const count = ref(1);
        const unwrappend = isRef(count) ? count.value : count;
 
        return &#123;
           count,
           unwrappend
        &#125;;
    &#125;
&#125;
</code></pre>
<h4 id="b-toRefs"><a href="#b-toRefs" class="headerlink" title="b) toRefs"></a>b) toRefs</h4><p>但是在具体的业务中，如果无法使用解构取出 <code>reactive()</code> 对象的值，每次都需要通过 <code>state.</code> 操作符访问它里面的属性会是非常麻烦的，所以官方提供了 <code>toRefs()</code> 函数来为我们填好这个坑。只要使用 <code>toRefs()</code> 把 <code>reactive()</code> 对象包装一下，就能够通过解构单独使用它里面的内容了。</p>
<p>toRefs 用于将响应式对象转换为结果对象，其中结果对象的每个属性都是指向原始对象相应属性的ref。</p>
<ul>
<li>toRefs之后得到的ref引用在获取数据值的时候需要加.value</li>
<li>toRefs后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据</li>
<li>作用其实和 toRef 类似，只不过 toRef 是一个个手动赋值，而 toRefs 是自动赋值。</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; name &#125;&#125; 价格:&#123;&#123; price &#125;&#125;
    购买数量:&#123;&#123;count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive,toRefs &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      //下面两种写法等效
      state.count += 1;
      // stateRefs.count.value+=1;
    &#125;

    const stateRefs = toRefs(state)

    return &#123; ...stateRefs, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="c-toRef"><a href="#c-toRef" class="headerlink" title="c) toRef"></a>c) toRef</h4><p>概念：为源响应式对象上的某个属性创建一个ref对象，二者内部操作的是同一个数据值，更新时二者是同步的。相当于浅拷贝一个属性。</p>
<ul>
<li>toRef之后得到的ref属性在获取数据值的时候需要加.value</li>
<li>toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据</li>
</ul>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;home&quot;&gt;
    名字:&#123;&#123; name &#125;&#125; 价格:&#123;&#123; price &#125;&#125;
    购买数量:&#123;&#123;count&#125;&#125;
    &lt;button @click=&quot;add&quot;&gt;点我加1&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; ref, reactive,toRef &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Home&quot;,
  components: &#123;
  &#125;,
  setup() &#123;
    //响应式对象
    const state = reactive(&#123;
      count: 0,
      name:&quot;商品1&quot;,
      price:100
    &#125;);
    //修改响应式对象
    function add() &#123;
      //下面两种写法等效
      //state.count += 1;
      count.value += 1;
    &#125;

    const count = toRef(state, &quot;count&quot;);

    return &#123; count, add &#125;;
  &#125;,
&#125;
&lt;/script&gt;
</code></pre>
<h4 id="d-ref-reactive-toRefs-和-toRef的比较"><a href="#d-ref-reactive-toRefs-和-toRef的比较" class="headerlink" title="d) ref reactive toRefs 和 toRef的比较"></a>d) ref reactive toRefs 和 toRef的比较</h4><p>**ref : **原始数据没有变化，而ref“包裹的数据”变成了一个新的对象，而且模板有变化（相当于深拷贝）</p>
<p>**reactive : **reactive处理的数据无论是原始数据，“包裹后的数据”，还是模板，都有变化（代理模式）</p>
<p><strong>toRef</strong> : toRef处理的数据会有变化，而原始数据也有变化，如果toRef处理是非响应式数据，此时模板没有变化 （相当于浅拷贝，引用关系）</p>
<p><strong>toRefs</strong> : toRefs处理的数据响应变化，原始数据也响应变化，如果toRefs处理是非响应式数据，此时模板并没有变化（相当于浅拷贝，引用关系）</p>
<p><img src="/2022/09/26/ref%E4%B8%8Ereactive/ref%E6%AF%94%E8%BE%83.jpg" alt="ref比较"></p>
<p>备注：ref也可以用来定义对象或数组，但内部会自动通过reactive转为代理对象</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ff7d73">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/ref与reactive/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/09/26/setup/">
        <h2>
            Setup
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/9/26
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p>1.理解：vue3.0中一个新的配置项，值为一个函数</p>
<p>2.setup是所有Composition API(组合API)表演的舞台</p>
<p>3.组件中所用到的：数据、方法等等，均要配置在setup中</p>
<p>4.setup函数的两种返回值</p>
<p>​    1.若要返回一个对象，则对象中的属性、方法，在模板中均可以直接使用。</p>
<p>​    2.若返回一个渲染函数，则可以自定义渲染内容</p>
<p>5.注意点：</p>
<p>1.尽量不要与vue2.x配置混用</p>
<ul>
<li>vue2.x配置（data、methods、computed…）中可以访问到setup中的属性、方法。</li>
<li>但在setup中不能访问到vue2.x配置（data、methods、computed…）</li>
<li>如果有重名，setup优先</li>
</ul>
<p>2.setup不能是一个async函数，因为返回值不再是return的对象，而是promise，模板看不到return对象中的属性。</p>
<h3 id="1-setup"><a href="#1-setup" class="headerlink" title="1 setup"></a>1 setup</h3><p>vue3.0将组件的逻辑都写在了函数内部，<code>setup()</code>会取代options API的<code>data()</code>函数，返回一个对象暴露给模板。</p>
<p> <code>setup</code> 选项在组件创建<strong>之前</strong>执行(所以在setup内部无法通过this来访问组件对象)，一旦 <code>props</code> 被解析，就将作为组合式 API 的入口。</p>
<p><code>setup</code> 函数是个新的入口函数，相当于 vue2.x 中 <code>beforeCreate </code>和 <code>created</code>，在 <code>beforeCreate</code> 之后 <code>created </code>之前执行。</p>
<p><strong>setup函数的特性：</strong></p>
<ul>
<li><p>使用Composition API 的入口</p>
</li>
<li><p>在beforeCreate之后在created之前执行</p>
</li>
<li><p>在setup中没有this,或者说this是undefined</p>
</li>
<li><p>可以返回一个对象，这个对象的属性被合并到渲染上下文，并可以在模板中直接使用；</p>
</li>
<li><p>接收props对象作为第一个参数，接收来的props对象，包含组件外部传递过来，且组件内部声明接收了的属性，可以通过watch监视其变化。</p>
</li>
<li><p>接受context对象作为第二个参数，这个对象包含attrs，slots，emit三个属性。</p>
<p>​       attrs:值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于<code>this.$attrs</code></p>
<p>​       slots:收到的插槽内容，相当于<code>this.$slots</code></p>
<p>​       emit:分发的自定义事件函数，相当于<code>this.$emit</code></p>
</li>
</ul>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/vue3" style="color: #ff7d73">
                vue3
            </a>
        </span>
        
    </div>
    <a href="/2022/09/26/setup/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/10/iconfont的使用/">
        <h2>
            Iconfont的使用
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/10
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <h2 id="1-在线使用"><a href="#1-在线使用" class="headerlink" title="1.在线使用"></a>1.在线使用</h2><p><strong>1.Symbol-在线使用</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step1.png"></p>
<p><strong>2.选择Symbol方式引入，复制链接，然后在index.html文件中引入</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step2.png"></p>
<pre><code>&lt;script src=&quot;https://at.alicdn.com/t/c/font_3572742_w51elmyzq3.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p><strong>3.加入通用css代码（引入一次即可）</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step3.png"></p>
<pre><code>.icon &#123;
  width: 1em;
  height: 1em;
  overflow: hidden;
  vertical-align: -0.15em;
  fill: currentColor;
&#125;
</code></pre>
<p>我放在了全局通用css文件里</p>
<p><strong>4.使用：挑选相应图标并获取类名，应用于页面</strong></p>
<pre><code>&lt;svg class=&quot;icon&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;use xlink:href=&quot;#icon-xxx&quot;&gt;&lt;/use&gt;
&lt;/svg&gt;
</code></pre>
<h2 id="2-Symbol-下载本地使用"><a href="#2-Symbol-下载本地使用" class="headerlink" title="2.Symbol-下载本地使用"></a>2.Symbol-下载本地使用</h2><p><strong>1.下载至本地</strong></p>
<p>****<img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step4.png"></p>
<p><strong>2.将其中的iconfont.js放到项目目录下，并在main.js中引入</strong></p>
<p><img src="/2022/08/10/iconfont%E7%9A%84%E4%BD%BF%E7%94%A8/step7.png"></p>
<p><strong>3.通用css和使用与在线使用相同</strong></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/css" style="color: #00bcd4">
                css
            </a>
        </span>
        
    </div>
    <a href="/2022/08/10/iconfont的使用/" class="go-post">
        阅读全文
    </a>
</div>

<div class="post">
    <a href="/2022/08/04/js循环/">
        <h2>
            Js循环
        </h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <svg class="fa-icon"><use xlink:href="#calendar-solid"></use></svg>
            </span>
            2022/8/4
        </span>
    </div>
    <div class="excerpt">
        <div class="content" v-pre>
            
            <p><strong>for循环</strong></p>
<p>for(初始化变量；条件表达式；操作表达式){</p>
<p>循环体</p>
<p>}</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <svg class="fa-icon"><use xlink:href="#tags-solid"></use></svg>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/js" style="color: #ffa2c4">
                js
            </a>
        </span>
        
    </div>
    <a href="/2022/08/04/js循环/" class="go-post">
        阅读全文
    </a>
</div>

             
<div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">
            1
        </span>
        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            
            <a href="/page/3">
                <span class="page-num">
                    3
                </span>
            </a>
            
            
            <span class="page-omit">...</span>
            <a href="/page/6">
                <span class="page-num">
                    6
                </span>
            </a>
            
        </span>
        
    </div>
    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <svg class="fa-icon"><use xlink:href="#caret-right-solid"></use></svg>
            </span>
        </a>
        
    </div>
</div>
        </div>
    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="https://img.gejiba.com/images/39def1210a35239bb3777e2c504985f1.jpg " alt="avatar">
        </div>
        <div class="name">
            参商
        </div>
        <div class="descriptions">
            
            <div class="description">
                yyds
            </div>
            
        </div>
        <div class="icon-links">
            
        </div>
        <div class="friend-links">
            
        </div>
    </div>
</div>
    </div>
    
</div>
                         
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2022 - 2022 mynote
            <span class="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            @参商
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>
</footer>
                    </div>
                </div>
            </transition>
            <div id="img_show">
                <img id="img_content" alt="img_show">
            </div>
        </div>
        <script src="https://cdn.staticfile.org/highlight.js/11.5.1/highlight.min.js"></script>
        <script src="/js/particlex.js"></script>
        <script src="/js/showimg.js"></script>
        

    </body>
</html>